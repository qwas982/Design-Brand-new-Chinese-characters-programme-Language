# 继续研究[`提示字编程语言`].


> 我来送给你一个核弹, [`提示字编程语言`].    
> 把提示字当函数、模块、控制流、功能开发.    
> 一种介于纯自然语言与伪代码之间的语义编程形式.    
> 还可以替代产品人擅长的PRD.    
> [`提示字编程语言`]写出来的代码也可以复用, 并且它是给大模型用的, 人类不需要逐行去写, 只要读和review即可.     
> 人类只要发送离散的、只言片语的、模糊的自然语言chat给大模型, 大模型理解后, 再用[`提示字编程语言`]写出这种代码,    
> 返回给人类审阅, 其中可以通过chat不断修改, 人类满意后, 再交给大模型,     
> 按照这种[`提示字编程语言`]代码去生成各种编程语言代码甚至汇编.    

> 不甚理想, 还需修正, 要更结构化, 比如C家族类似的语法, 但是更通用, 更近似自然语言伪代码.    
> 为啥不用中文汉字编程的形式演示?    

> 嗯, 效果已经较为理想了,    
> 换一种风格呢? 换成lisp/Scheme家族风格演示看看.    

> 唉呀, 糟糕了, Lisp/Scheme风格就需要更加地偏向于自然语言化+伪代码化. 并保持一定的程序结构.    
> 要把函数式的精华学到.    


---


### 优势特性;    

人类友好 - 比代码更易读，比PRD更结构化    

AI优化 - 结构清晰，减少歧义    

语言无关 - 可生成Python、Java、JavaScript等任何语言    

版本可控 - 可作为文档保存，跟踪需求变更    

可测试性 - 内置测试用例定义    

渐进细化 - 从模糊到精确的迭代过程    

结构清晰：类似编程语言的语法结构    

语义明确：比伪代码更精确，比代码更易读    

可验证：能进行基本语法检查    

可转换：能准确映射到各种编程语言    

可协作：产品、开发、AI都能理解    

母语友好 - 中文使用者更容易理解和审阅    

语义清晰 - 结构化的中文比自然语言更精确    

文化适配 - 使用中文的业务术语和表达习惯    

减少歧义 - 形式化的中文减少了自然语言的模糊性    

转换直接 - AI能直接理解并生成靶代码    

这种中文结构化语义编程让产品经理、业务分析师等非技术背景人员也能清晰地表达复杂业务逻辑，同时为AI提供了精确的生成规范，减少理解和沟通成本。    

这个设计让产品经理、开发者、AI能在同一语义层面协作，大幅降低沟通成本，同时保留足够的精确性用于代码生成。    

---

核心突破：解决了什么?    

| 问题       | 现状               | PromptIR 方案                                 |
| -------- | ---------------- | ------------------------------------------- |
| **语义漂移** | 每次对话上下文丢失，得重新描述  | PromptIR 是**唯一事实来源**，可引用、可组合                |
| **不可复用** | 提示字藏在聊天记录里，无法版本化 | `@module` 是带版本、约束的**可导入库**                  |
| **无法审查** | 自然语言模糊，技术细节缺失    | 混合了形式化约束（`bcrypt(cost=12)`）与高层语义            |
| **目标单一** | 一次对话只生成一种语言代码    | 一份 PromptIR **翻译到多个靶**（Python/Go/PRD/测试用例）  |
| **信任缺失** | 黑盒生成，人类不敢直接上线    | PromptIR 是**可审计的白盒契约**，人类 review 的是架构，不是代码行 |


### 范式转变：    

人类角色：从"代码作者"变为架构契约设计师    
模型角色：从"一次性代码生成器"变为 PromptIR 翻译器后端    
交付物：PromptIR 文件成为比代码更高阶的数字资产（代码只是它的一个翻译产物）    


---

终极形态 > PromptIR 即产品    
当生态成熟后，你对话的对象不再是模型，而是 @生态系统的 PromptIR 模块：    

```js
人类：我要一个电商后台
系统：导入 @EcommerceCore v5.1？它依赖 @Payment/Stripe 和 @Auth/OIDC
人类：支付改成支付宝，加上库存防超卖
系统：生成 diff，修改 @Payment 子模块，新增 @Inventory/Reserve 行为约束
人类：OK，翻译成 Go+React，部署到 K8s
系统：翻译中... 生成代码、Dockerfile、Helm chart、监控规则、操作手册
```

> 人类只提供离散、模糊的自然语言，    
> AI 负责翻译为结构化、可复用、可翻译的“提示字代码”，    
> 人类仅审阅高层语义，最终由 AI 翻译为任意靶语言。    

这实际上定义了一个三层架构：    

意图层（Human）：模糊、离散、非形式化（如：“加个登录，要安全”）    
语义中间层（Prompt-based IR）：结构化、可组合、可复用的提示字模块    
实现层（AI Compiler）：翻译成 Python/JS/汇编等靶代码    

这种范式若成熟，会真正实现 “编程民主化” 与 “需求-实现零摩擦”。    
但方向已明：提示即程序，对话即开发。    

```js
: 人类输入 "做个安全登录"
  → AI 生成上述 模块 登录功能
  → 人类审阅： “密码要加盐哈希，会话要支持刷新”
  → AI 修改：插入 校验密码 = 比较(哈希(凭证.密码 + 用户.盐), 用户.哈希)
  → 人类确认
  → AI 翻译 → 输出 Python/Go/Rust 实现
;
```

结构清晰：保留 `{}` 块、缩进、作用域，避免纯自然语言的歧义。    
自然可读：关键字用中文（或任意自然语言），非程序员也能理解逻辑。    
可复用：`模块` 可被其他提示字代码 `引用 登录功能`。    
可翻译：大模型可将其映射到任意靶语言的 AST。    
可测试：每个 `函数` 可独立生成单元测试桩。    

---

# 甲:

```js
<程序>               ::= { <顶部声明> }

<顶部声明>          ::= <模块声明>
                     | <函数声明>
                     | <常量声明>

<模块声明>          ::= «模块» <标识符> «{» { <模块成员> } «}»
<模块成员>          ::= <函数声明>
                     | <类型声明>
                     | <常量声明>

<函数声明>          ::= «函数» <标识符> «(» [ <参数列表> ] «)» «{» <语句块> «}»

<参数列表>          ::= <参数> { «,» <参数> }
<参数>              ::= <标识符> [ «:» <类型名> ]

<类型声明>          ::= «类型» <标识符> «{» { <字段声明> } «}»
<字段声明>          ::= «字段» <标识符> «:» <类型名> «;»

<常量声明>          ::= «常量» <标识符> «=» <字面量> «;»

<语句块>            ::= { <语句> }

<语句>              ::= <赋值语句>
                     | <条件语句>
                     | <循环语句>
                     | <返回语句>
                     | <抛出语句>
                     | <表达式语句>
                     | «{» <语句块> «}»

<赋值语句>          ::= <左值> «=» <表达式> «;»

<条件语句>          ::= «如果» <表达式> «{» <语句块> «}» [ «否则» <否则分支> ]
<否则分支>          ::= «{» <语句块> «}»
                     | <条件语句>        // 支持 else if 链

<循环语句>          ::= «循环» «每项» <标识符> «在» <表达式> «{» <语句块> «}»

<返回语句>          ::= «返回» [ <表达式> ] «;»
<抛出语句>          ::= «抛出» <表达式> «;»

<表达式>            ::= <逻辑或表达式>
<逻辑或表达式>      ::= <逻辑与表达式> { «或» <逻辑与表达式> }
<逻辑与表达式>      ::= <相等表达式> { «且» <相等表达式> }
<相等表达式>        ::= <关系表达式> [ ( «==» | «!=» ) <关系表达式> ]
<关系表达式>        ::= <加法表达式> [ ( «<» | «<=» | «>» | «>=» ) <加法表达式> ]
<加法表达式>        ::= <乘法表达式> { ( «+» | «-» ) <乘法表达式> }
<乘法表达式>        ::= <一元表达式> { ( «*» | «/» ) <一元表达式> }
<一元表达式>        ::= [ «!» | «-» ] <主表达式>
<主表达式>          ::= <字面量>
                     | <标识符>
                     | <函数调用>
                     | «(» <表达式> «)»
                     | <成员访问>

<函数调用>          ::= <标识符> «(» [ <实参列表> ] «)»
<实参列表>          ::= <表达式> { «,» <表达式> }
<成员访问>          ::= <主表达式> «.» <标识符>

<字面量>            ::= «数字»
                     | «字符串»
                     | «真»
                     | «假»
                     | «空»

<类型名>            ::= «整数» | «浮点» | «字符串» | «布尔» | «空»
                     | <标识符>                // 用户自定义类型

<标识符>            ::= [a-zA-Z_4E00-9FFF][a-zA-Z0-9_4E00-9FFF]*   // 实际支持中文标识符，此处为简化
```


> 此 BNF 兼具 结构性（块、作用域、控制流）与 自然语言亲和力（关键字为中文语义词），    
> 且无符号歧义（如 `=` 仅用于赋值，`==` 用于对比）。    

---

```js
类型 用户ID : 整数
类型 邮箱 : 字符串 [格式:邮箱]
类型 用户名 : 字符串 [最小:3, 最大:20]
类型 密码 : 字符串 [最小:8, 要求:大写字母,数字]

结构体 用户 {
    标识: 用户ID
    名称: 用户名
    邮箱: 邮箱
    状态: 枚举[激活中, 待验证, 已禁用]
}

集合<用户> 用户列表

函数 注册用户(
    姓名: 用户名,
    邮箱: 邮箱,
    密码: 密码,
    角色: 用户角色 = 用户角色.普通用户
) -> 结果<用户ID, 错误> {
    // 函数体使用结构化语义
}

控制流程 注册流程 {
    输入: 注册请求
    输出: 注册响应
    
    步骤 验证输入 {
        如果 邮箱格式无效 则 {
            返回 错误.无效邮箱
        }
        
        检查 用户名可用性
        检查 邮箱唯一性
    }
    
    步骤 处理数据 {
        密码哈希 = 哈希(密码 使用 SHA256)
        验证令牌 = 生成随机令牌()
        设置 用户状态 = 待验证
    }
    
    步骤 持久化数据 {
        开始 事务
        插入到 用户表
        插入到 验证令牌表
        提交 事务
        
        当失败时 回滚 并 返回 错误.数据库错误
    }
    
    步骤 通知用户 {
        异步 发送验证邮件(邮箱, 令牌)
        异步 发送欢迎通知(邮箱, 姓名)
        
        跟踪失败但不阻塞主流程
    }
}


控制流程 注册流程 {
    输入: 注册请求
    输出: 注册响应
    
    步骤 验证输入 {
        如果 邮箱格式无效 则 {
            返回 错误.无效邮箱
        }
        
        检查 用户名可用性
        检查 邮箱唯一性
    }
    
    步骤 处理数据 {
        密码哈希 = 哈希(密码 使用 SHA256)
        验证令牌 = 生成随机令牌()
        设置 用户状态 = 待验证
    }
    
    步骤 持久化数据 {
        开始 事务
        插入到 用户表
        插入到 验证令牌表
        提交 事务
        
        当失败时 回滚 并 返回 错误.数据库错误
    }
    
    步骤 通知用户 {
        异步 发送验证邮件(邮箱, 令牌)
        异步 发送欢迎通知(邮箱, 姓名)
        
        跟踪失败但不阻塞主流程
    }
}
```

---

```js
模块 订单处理系统 {
    导入 支付网关
    导入 库存管理
    导入 物流服务
    导入 通知中心
    
    // 定义类型
    类型 订单请求 {
        用户标识: 整数
        商品列表: 数组<订单项>
        收货地址: 地址结构
        支付方式: 枚举[支付宝, 微信, 银行卡]
        优惠券: 可选 字符串
    }
    
    类型 订单项 {
        商品标识: 整数
        数量: 整数 [最小:1]
        单价: 小数 [精度:2]
    }
    
    类型 订单结果 {
        成功: 布尔值
        订单号: 可选 字符串
        总金额: 小数
        预计送达时间: 可选 日期时间
        错误信息: 数组<字符串>
    }
    
    // 主订单处理函数
    函数 创建订单(请求: 订单请求) -> 订单结果 {
        // 验证阶段
        验证结果 = 验证订单请求(请求)
        如果 非 验证结果.有效 则 {
            返回 订单结果 {
                成功: 假,
                错误信息: 验证结果.错误列表
            }
        }
        
        // 计算价格
        价格计算 = 计算订单价格(请求)
        
        // 检查库存
        库存检查 = 并行 {
            检查库存(请求.商品列表)
            检查限购规则(请求.用户标识, 请求.商品列表)
        }
        
        // 处理支付
        支付结果 = 处理支付({
            金额: 价格计算.总金额,
            方式: 请求.支付方式,
            用户: 请求.用户标识
        })
        
        如果 支付结果.状态 != 支付状态.成功 则 {
            返回 订单结果 {
                成功: 假,
                错误信息: ["支付失败: " + 支付结果.原因]
            }
        }
        
        // 创建订单记录
        订单标识 = 数据库.事务 {
            订单号 = 生成订单号()
            插入订单记录(订单号, 请求, 价格计算)
            减少库存(请求.商品列表)
            记录支付信息(支付结果.交易号)
        }
        
        // 后续处理
        异步 {
            发送订单确认(请求.用户标识, 订单号)
            通知仓库发货(订单号, 请求.收货地址)
            更新用户订单历史(请求.用户标识, 订单号)
        }
        
        返回 订单结果 {
            成功: 真,
            订单号: 订单号,
            总金额: 价格计算.总金额,
            预计送达时间: 计算送达时间(请求.收货地址)
        }
    }
    
    // 价格计算流程
    控制流程 计算订单价格(订单请求) -> 价格详情 {
        商品总价 = 0
        
        循环 每个 商品项 在 订单请求.商品列表 {
            项价格 = 商品项.数量 * 商品项.单价
            商品总价 = 商品总价 + 项价格
        }
        
        // 应用优惠券
        折扣金额 = 0
        如果 订单请求.优惠券 存在 则 {
            折扣金额 = 验证并应用优惠券(订单请求.优惠券, 商品总价)
        }
        
        // 计算运费
        运费 = 计算运费({
            地址: 订单请求.收货地址,
            商品数量: 订单请求.商品列表.长度,
            总重量: 计算总重量(订单请求.商品列表)
        })
        
        // 会员折扣
        用户等级 = 获取用户等级(订单请求.用户标识)
        等级折扣 = 开关 用户等级 {
            案例 普通会员: 商品总价 * 0.02
            案例 黄金会员: 商品总价 * 0.05
            案例 铂金会员: 商品总价 * 0.10
            默认: 0
        }
        
        总金额 = 商品总价 - 折扣金额 - 等级折扣 + 运费
        
        返回 价格详情 {
            商品总价: 商品总价,
            折扣金额: 折扣金额,
            等级折扣: 等级折扣,
            运费: 运费,
            总金额: 总金额
        }
    }
    
    // 错误处理策略
    错误策略 订单错误处理 {
        当 库存不足错误 -> 返回错误并建议替代商品
        当 支付失败错误 -> 记录日志并通知用户重试
        当 地址无效错误 -> 提示用户修改地址
        当 系统错误 -> 记录错误并通知运维人员
    }
}


测试套件 订单创建测试 {
    测试用例 "正常创建订单" {
        给定 合法订单请求 = {
            用户标识: 12345,
            商品列表: [
                {商品标识: 1001, 数量: 2, 单价: 299.99},
                {商品标识: 1002, 数量: 1, 单价: 599.00}
            ],
            收货地址: {省份: "北京", 城市: "北京市", 详细地址: "海淀区...", 电话: "13800138000"},
            支付方式: 支付宝,
            优惠券: "SUMMER2023"
        }
        
        当 结果 = 创建订单(合法订单请求)
        
        那么 {
            断言 结果.成功 == 真
            断言 结果.订单号 不为空
            断言 结果.总金额 > 0
            断言 数据库.订单表存在(结果.订单号)
            断言 库存.商品1001库存 == 原始库存 - 2
        }
    }
    
    测试用例 "库存不足时创建订单失败" {
        给定 库存不足请求 = {
            用户标识: 12345,
            商品列表: [{商品标识: 9999, 数量: 9999, 单价: 10.00}],
            收货地址: 有效地址,
            支付方式: 微信支付
        }
        
        当 结果 = 创建订单(库存不足请求)
        
        那么 断言 结果.成功 == 假
             断言 结果.错误信息 包含 "库存不足"
    }
}
```

---

协作流程演示;    
产品需求输入（自然中文）,    
```bash
"我们需要一个请假审批系统：
1. 员工提交请假申请，包含请假类型、时间、原因
2. 根据请假天数自动路由审批人
3. 少于3天直接上级审批，3-7天需要部门总监审批
4. 支持审批人驳回、通过、转交
5. 审批通过后自动扣除假期余额
6. 整个流程要邮件通知"
```


AI生成的[`提示字编程语言`]带有中文语义的程序代码.    
```js
模块 请假审批系统 {
    导入 员工目录
    导入 邮件服务
    导入 假期余额管理
    
    类型 请假申请 {
        员工标识: 整数
        请假类型: 枚举[年假, 病假, 事假, 调休]
        开始时间: 日期时间
        结束时间: 日期时间
        请假原因: 字符串 [最大:500]
        附件: 可选 文件列表
    }
    
    类型 审批结果 {
        状态: 枚举[已提交, 审批中, 已批准, 已驳回, 已取消]
        审批人列表: 数组<审批节点>
        当前审批人: 可选 字符串
        审批意见: 可选 字符串
    }
    
    // 主请假流程
    函数 提交请假申请(申请: 请假申请) -> 请假单号 {
        // 验证申请
        验证结果 = 验证请假申请(申请)
        如果 非 验证结果.有效 则 {
            抛出 验证错误(验证结果.错误信息)
        }
        
        // 计算请假天数
        请假天数 = 计算工作日天数(申请.开始时间, 申请.结束时间)
        
        // 检查假期余额
        可用余额 = 获取假期余额(申请.员工标识, 申请.请假类型)
        如果 请假天数 > 可用余额 则 {
            抛出 余额不足错误(申请.请假类型, 可用余额, 请假天数)
        }
        
        // 确定审批流程
        审批流程 = 确定审批流程({
            员工标识: 申请.员工标识,
            请假类型: 申请.请假类型,
            请假天数: 请假天数
        })
        
        // 创建请假记录
        请假单号 = 生成请假单号()
        数据库.事务 {
            插入请假记录(请假单号, 申请)
            初始化审批流程(请假单号, 审批流程)
            锁定假期额度(申请.员工标识, 申请.请假类型, 请假天数)
        }
        
        // 通知审批人
        异步 通知第一审批人(请假单号, 审批流程.第一审批人)
        
        返回 请假单号
    }
    
    // 审批流程决策
    控制流程 确定审批流程(参数) -> 审批路径 {
        开关 参数.请假天数 {
            案例 当 天数 < 3:
                审批人 = 获取直接上级(参数.员工标识)
                返回 单级审批(审批人)
                
            案例 当 天数 >= 3 且 天数 <= 7:
                直接上级 = 获取直接上级(参数.员工标识)
                部门总监 = 获取部门总监(参数.员工标识)
                返回 两级审批([直接上级, 部门总监])
                
            案例 当 天数 > 7:
                直接上级 = 获取直接上级(参数.员工标识)
                部门总监 = 获取部门总监(参数.员工标识)
                人力资源 = 获取HR审批人()
                返回 三级审批([直接上级, 部门总监, 人力资源])
        }
    }
    
    // 审批操作
    函数 审批请假(请假单号: 字符串, 审批人: 字符串, 决定: 审批决定, 意见: 可选 字符串) {
        验证审批权限(请假单号, 审批人)
        
        更新审批状态(请假单号, 审批人, 决定, 意见)
        
        如果 决定 == 审批决定.批准 则 {
            下一个审批人 = 获取下一审批人(请假单号)
            如果 下一个审批人 存在 则 {
                异步 通知审批人(请假单号, 下一个审批人)
            } 否则 {
                完成审批流程(请假单号)
                扣除假期余额(请假单号)
                通知申请人审批完成(请假单号)
            }
        } 否则 如果 决定 == 审批决定.驳回 则 {
            结束审批流程(请假单号, 状态.已驳回)
            释放锁定额度(请假单号)
            通知申请人审批驳回(请假单号, 意见)
        }
    }
    
    // 邮件通知模板
    模板 审批通知邮件 {
        收件人: ${审批人.邮箱}
        主题: "待审批请假申请: ${请假单号}"
        正文: """
        ${审批人.姓名}, 您好!
        
        员工 ${申请人.姓名} 提交了请假申请:
        - 请假类型: ${请假类型}
        - 时间: ${开始时间} 至 ${结束时间}
        - 天数: ${请假天数}
        - 原因: ${请假原因}
        
        请登录系统审批: ${审批链接}
        """
    }
}
```

翻译演示,    
```python
带有中文语义的程序代码 → Python代码
-------------------------------------------
函数 计算订单价格(订单请求) → def calculate_order_price(order_request):
类型 订单项 → class OrderItem:
循环 每个 商品项 → for item in order_items:
如果 非 验证结果.有效 → if not validation_result.valid:
异步 发送邮件 → asyncio.create_task(send_email())
```

---

# 乙:    

```js
// ============================================================
// 模块：用户认证服务
// 版本：2.3.1 | 作者：架构组 | 安全等级：P1
// ============================================================
模块 UserAuth {
    // 依赖声明（自动注入与版本锁定）
    引入 Cache 从 "@infra/redis" 版本 4.1.0
    引入 Audit 从 "@compliance/logger" 版本 1.8.0

    // 类型别名：人类可读的类型约束
    类型 Username = 字符串(长度: 3..20, 正则: "^[a-zA-Z0-9_]+$")
    类型 Password = 字符串(最小熵: 50, 禁用常见密码: 真)
    类型 UserId = UUID

    // 常量与配置（可覆盖）
    常量 最大重试次数 = 5
    常量 锁定时间 = 时长("1h")

    // ========================================================
    // 函数：验证用户密码
    // 契约：前置、后置、异常
    // ========================================================
    函数 认证(用户名: Username, 密码: Password) 
        -> 结果<UserId, 认证错误>
    {
        // 前置条件：不可变约束，编译时检查
        前置条件 {
            用户名 != 空 且 密码 != 空
            非 是否被限流(客户端IP)  // 隐式注入客户端IP
        }

        // 主逻辑：自然语言语句 + 结构化控制流
        步骤("查询用户记录") {
            用户 = 数据库.查询(
                "SELECT id, password_hash FROM users WHERE username = ?", 
                用户名
            )
            如果 用户.为空 {
                // 统一异常：代码生成时自动包装
                抛出 认证错误.用户未找到
                    .附带日志级别("WARN")
                    .附带指标("auth.failure.count++")
            }
        }

        步骤("验证密码强度与哈希") {
            // 内联约束：仅作用于本步骤
            响应时间(介于: 300毫秒..500毫秒)  // 防时序攻击
            哈希结果 = bcrypt.比对(
                密码, 
                用户.password_hash, 
                成本: 12
            )
        }

        步骤("处理认证结果") {
            如果 哈希结果.有效 {
                并行执行 {
                    Audit.记录(
                        事件: "user.login.success",
                        用户Id: 用户.id,
                        IP: 客户端IP
                    )
                    Cache.删除(键: "rate_limit:{客户端IP}")  // 成功清除限流
                }
                返回 成功(用户.id)
            } 否则 {
                // 异常路径：自动触发审计和限流
                抛出 认证错误.凭证无效
                    .附带副作用 {
                        记录失败尝试(用户名)
                        Audit.记录(
                            事件: "user.login.failure",
                            用户Id: 用户.id,
                            IP: 客户端IP,
                            原因: "password_mismatch"
                        )
                    }
            }
        }

        // 后置条件：确保资源清理与状态一致性
        后置条件 {
            数据库.连接.已关闭()
            Cache.已释放()
        }

        // 异常契约：结构化异常处理（类似Java catch）
        捕获 {
            情况 认证错误.用户未找到:
                // 欺骗型延迟：防用户名枚举
                睡眠(随机(200毫秒..400毫秒))
                返回 失败(认证错误.凭证无效)  // 模糊化错误
                
            情况 认证错误.凭证无效:
                如果 获取失败次数(用户名) >= 最大重试次数 {
                    锁定账户(用户名, 时长: 锁定时间)
                }
                返回 失败(认证错误.凭证无效)
                
            情况 数据库错误:
                // 降级策略：熔断
                熔断器.触发("user_db")
                返回 失败(认证错误.服务不可用)
                
            默认:
                Audit.记录(事件: "auth.unexpected_error", 错误: 错误)
                返回 失败(认证错误.内部错误)
        }
    }

    // ========================================================
    // 辅助函数：限流检查（私有）
    // ========================================================
    私有 函数 是否被限流(IP地址: 字符串) -> 布尔值 {
        // 约束驱动实现：模型知道该选Redis令牌桶还是漏桶
        约束 {
            算法: "token_bucket",
            容量: 10,
            速率: 每秒1个,
            存储: Cache
        }
        
        // 自然语言逻辑：模型决定具体命令（INCR/EVAL）
        检查限流 in Cache 对于 键 "rate_limit:{IP地址}"
        
        返回 检查限流.已超限
    }

    // ========================================================
    // 测试用例：作为函数的一部分，可提取执行
    // ========================================================
    测试 {
        用例 "正常登录" {
            假设: 用户名="alice", 密码="Valid123!"
            模拟: 数据库.返回(用户存在), bcrypt.返回(真)
            期望: 成功(用户Id="uuid-alice")
            期望: Audit.记录.被调用(次数: 1)
        }
        
        用例 "密码错误触发限流" {
            假设: 用户名="bob", 密码="WrongPass"
            重复: 5 次
            期望: 失败(凭证无效)
            
            第6次尝试:
                期望: 失败(账户已锁定)
                期望: Cache.设置(键: "lock:bob", 过期: 1小时)
        }
        
        用例 "数据库宕机触发熔断" {
            模拟: 数据库.抛出(数据库错误)
            期望: 失败(服务不可用)
            期望: 熔断器.触发("user_db")
        }
    }
}

// ============================================================
// 主流程：组合模块，定义编排
// ============================================================
工作流 创建用户文章 {
    // 输入DTO：结构化schema，可生成TypeScript/Java类
    输入 {
        标题: 字符串(长度: 5..100, 必填: 真)
        内容:  Markdown(最大长度: 10_000)
        标签: 数组<字符串>(最大数量: 5)
        草稿: 布尔值(默认: 假)
    }

    // 步骤编排：显式顺序、并行、Saga事务
    步骤们 {
        步骤1: 认证用户 {
            // 调用模块函数，自动注入上下文
            认证结果 = UserAuth.认证(
                从请求头("X-User-Token")
            )
            // 短路失败：认证结果必须是成功
            要求 认证结果.是成功
            用户Id = 认证结果.值
        }

        步骤2: 检查权限 {
            // RBAC检查：自然语言策略
            有权限 = RBAC.检查(
                用户Id,
                "post:create",
                资源: 输入.标签
            )
            要求 有权限 否则 抛出 无权限错误
        }

        步骤3: 校验内容 {
            // 并行校验：模型知道如何优化
            并行 {
                垃圾分 = 机器学习模型.预测("spam_detector", 输入.内容)
                要求 垃圾分 < 0.8
                
                毒性 = 机器学习模型.预测("toxicity", 输入.内容)
                要求 毒性 < 0.5
            }
        }

        步骤4: 保存到数据库 {
            // Saga事务：成功则提交，失败则补偿
            事务(类型: saga) {
                文章Id = 数据库.插入("posts", {
                    标题: 输入.标题,
                    内容: 输入.内容,
                    用户Id: 用户Id,
                    草稿: 输入.草稿
                })
                
                // 补偿动作：生成时自动创建rollback函数
                补偿 {
                    数据库.删除("posts", 编号: 文章Id)
                    Audit.记录(事件: "post.create.rollback", 文章Id: 文章Id)
                }
            }
        }

        步骤5: 更新侧边栏缓存 {
            // 异步副作用：不要求强一致性
            异步执行 {
                Cache.失效(模式: "sidebar:recent_posts:*")
            }
        }

        步骤6: 通知关注者 {
            // 消息队列：模型选择Kafka/RabbitMQ
            发送事件(
                主题: "social.post_created",
                负载: {
                    文章Id: 文章Id,
                    作者Id: 用户Id,
                    标签: 输入.标签
                },
                可靠性: "至少一次"
            )
        }
    }

    // 输出契约：后处理与格式化
    输出 {
        状态: "已创建"
        文章Id: 文章Id
        链接: 格式化("/posts/{文章Id}")
        // 自动处理敏感字段脱敏
        脱敏: ["用户Id"]
    }

    // 性能与非功能需求：全局约束
    约束 {
        超时: 时长("5秒")
        内存: 最大("256MB")
        CPU: 最大("100毫秒")
        重试: 次数(3, 退避: 指数)
        熔断器: "默认"
    }

    // 监控埋点：自动生成Prometheus/Metrics代码
    遥测 {
        指标: "post.create.duration".直方图(桶: [100毫秒, 500毫秒, 1秒])
        指标: "post.create.failure".计数器
        追踪: 跨度("create-post", 传播: 真)
    }
}
```

---

大模型翻译靶点对比：汉字PromptIR → 代码,    
输入（汉字PromptIR片段）：    
```cpp
步骤("查询用户") {
    用户 = 数据库.查询("SELECT * FROM users WHERE id = ?", 用户Id)
    如果 用户.为空 {
        抛出 错误.用户未找到
    }
}
约束 {
    超时: 100毫秒
    重试: 3次
}
```

翻译为 Go：    
```go
// 自动生成的生产级代码
func (r *userRepo) GetUser(ctx context.Context, userID string) (*User, error) {
    ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
    defer cancel()
    
    var user User
    err := retry.WithAttempts(3, func() error {
        return r.db.QueryRowContext(ctx, 
            "SELECT * FROM users WHERE id = ?", userID).Scan(&user)
    })
    
    if err == sql.ErrNoRows {
        return nil, ErrUserNotFound // 带堆栈追踪
    }
    return &user, err
}
```

翻译为 Python：    
```python
# 自动生成的async函数
@retry(stop=stop_after_attempt(3))
@timeout(0.1)  # 100ms
async def get_user(user_id: str) -> User:
    async with db.acquire() as conn:
        row = await conn.fetchrow(
            "SELECT * FROM users WHERE id = $1", user_id
        )
        if not row:
            raise UserNotFoundError().with_stacktrace()
        return User(**row)
        
```

翻译为 PRD 文档：    
```md
### 3.2 用户查询功能

**业务规则**：
- 若用户ID不存在，系统应抛出"用户未找到"错误
- 操作超时时间：100ms（避免级联延迟）
- 自动重试：最多3次（应对瞬时网络抖动）

**异常处理**：
| 错误类型 | 用户提示 | 监控指标 |
|----------|----------|----------|
| 用户未找到 | "账号不存在" | `user.not_found` +1 |
| 超时 | "服务繁忙" | `db.timeout` +1 |
```

---

# 丙:    

```js
模块 登录功能 {
  输入 用户凭证 {
    字段 用户名 : 字符串;
    字段 密码   : 安全字符串;
  }

  函数 验证凭证(凭证) {
    如果 凭证.用户名 为空 或 凭证.密码 长度 < 8 {
      抛出 错误("用户名或密码格式无效");
    }
    返回 真;
  }

  函数 生成会话(用户ID) {
    会话 = 创建新会话(用户ID, 有效期: 2小时);
    返回 会话令牌;
  }

  入口 处理登录请求(请求体) {
    凭证 = 解析(请求体);
    如果 验证凭证(凭证) {
      用户 = 查询用户(凭证.用户名);
      如果 用户 且 校验密码(凭证.密码, 用户.哈希) {
        令牌 = 生成会话(用户.ID);
        返回 成功(数据: { 会话令牌: 令牌 });
      } 否则 {
        返回 失败(原因: "认证失败");
      }
    }
  }
}


函数 计算平均分(成绩列表) {
  总分 = 0;
  计数 = 0;
  循环 每项 成绩 在 成绩列表 {
    如果 成绩 >= 0 {
      总分 = 总分 + 成绩;
      计数 = 计数 + 1;
    }
  }
  如果 计数 > 0 {
    返回 总分 / 计数;
  } 否则 {
    返回 空;
  }
}
```

句法上：用 BNF 严格定义，类 C 结构，自然语言关键字。    
语义上：保留计算逻辑，但消除符号噪音。    
工程上：可作为 PRD 与代码的中间表示（IR），实现 “对话即开发”。    
```js
模块 Todo应用 {
  类型 Todo项 {
    字段 ID       : 整数;
    字段 标题     : 字符串;
    字段 已完成   : 布尔;
    字段 创建时间 : 字符串;
  }

  常量 下一个ID = 1;

  函数 生成ID() {
    旧ID = 下一个ID;
    下一个ID = 下一个ID + 1;
    返回 旧ID;
  }

  函数 创建Todo(标题) {
    如果 标题 为空 {
      抛出 错误("标题不能为空");
    }
    todo = {
      ID: 生成ID(),
      标题: 标题,
      已完成: 假,
      创建时间: 当前时间戳()
    };
    添加到列表(todo);
    返回 成功(数据: todo);
  }

  函数 获取所有Todo() {
    返回 成功(数据: 全局Todo列表);
  }

  函数 更新Todo状态(ID, 新状态) {
    todo = 查找TodoByID(ID);
    如果 todo 为空 {
      返回 失败(原因: "未找到该任务");
    }
    todo.已完成 = 新状态;
    返回 成功(数据: todo);
  }

  函数 删除Todo(ID) {
    如果 从列表移除(ID) {
      返回 成功(消息: "已删除");
    } 否则 {
      返回 失败(原因: "任务不存在");
    }
  }

  // --- 内部辅助函数 ---
  函数 添加到列表(项) {
    全局Todo列表.追加(项);
  }

  函数 查找TodoByID(ID) {
    循环 每项 t 在 全局Todo列表 {
      如果 t.ID == ID {
        返回 t;
      }
    }
    返回 空;
  }

  // --- 入口控制器 ---
  入口 处理请求(方法, 路径, 请求体) {
    如果 方法 == "POST" 且 路径 == "/todos" {
      返回 创建Todo(请求体.标题);
    } 否则 如果 方法 == "GET" 且 路径 == "/todos" {
      返回 获取所有Todo();
    } 否则 如果 方法 == "PATCH" 且 路径 以 "/todos/" 开头 {
      ID = 提取ID(路径);
      返回 更新Todo状态(ID, 请求体.已完成);
    } 否则 如果 方法 == "DELETE" 且 路径 以 "/todos/" 开头 {
      ID = 提取ID(路径);
      返回 删除Todo(ID);
    } 否则 {
      返回 失败(原因: "未支持的路由");
    }
  }
}
```

---

# 丁:    

【`提示字编程语言`】函数式自然语言风格演示,    

```lisp
(定义 注册用户
  "接收用户名、邮箱和密码，注册新用户"
  (参数 (用户名 字符串) (邮箱 字符串) (密码 字符串))
  
  (执行
    ;; 第一步：验证输入
    "检查邮箱格式是否有效"
    (如果 (邮箱无效? 邮箱)
          (返回 "邮箱格式错误"))
    
    "检查用户名是否已存在"
    (如果 (用户存在? 用户名)
          (返回 "用户名已被使用"))
    
    ;; 第二步：处理数据
    "对密码进行哈希加密"
    (设置 密码哈希 (哈希密码 密码))
    
    "生成邮箱验证令牌"
    (设置 验证令牌 (生成令牌))
    
    ;; 第三步：保存数据
    "将用户信息保存到数据库"
    (数据库操作
      (插入用户 用户名 邮箱 密码哈希)
      (插入验证令牌 验证令牌))
    
    ;; 第四步：发送通知
    "异步发送验证邮件"
    (异步 (发送邮件 邮箱 "验证邮件" 验证令牌))
    
    "返回成功结果"
    (返回 (成功 用户名))))

(定义 处理订单数据
  "处理原始订单数据，清洗、转换、验证"
  (参数 (原始订单 列表))
  
  (执行
    "数据处理管道"
    (-> 原始订单
        ;; 第一步：过滤无效订单
        (过滤 (λ (订单) (订单有效? 订单)))
        
        ;; 第二步：转换日期格式
        (映射 (λ (订单) 
                (更新 订单 
                      (创建时间 (标准化日期 订单.创建时间)))))
        
        ;; 第三步：计算价格
        (映射 (λ (订单)
                (更新 订单
                      (总价 (计算总价 订单.商品列表))
                      (折扣 (计算折扣 订单.用户等级)))))
        
        ;; 第四步：分组统计
        (按 用户ID 分组)
        (映射-值 (λ (用户订单)
                   (统计 用户订单
                         (总订单数 (长度))
                         (总金额 (求和 .总价))
                         (平均单价 (平均值 .单价)))))
        
        ;; 第五步：转换为JSON
        (转换为JSON))))
        
(定义 处理用户请求
  "根据用户请求类型执行相应操作"
  (参数 (请求 结构))
  
  (执行
    "匹配请求类型并处理"
    (匹配 请求.类型
      ;; 情况1：登录请求
      ((等于 "登录")
       "验证用户凭证"
       (如果 (验证登录 请求.用户名 请求.密码)
             (返回 (成功 "登录成功"))
             (返回 (失败 "用户名或密码错误"))))
      
      ;; 情况2：注册请求
      ((等于 "注册")
       "注册新用户"
       (尝试
         (注册用户 请求.用户名 请求.邮箱 请求.密码)
         (捕获 错误
           (返回 (失败 错误.消息)))))
      
      ;; 情况3：找回密码
      ((等于 "找回密码")
       "发送密码重置邮件"
       (异步 (发送重置邮件 请求.邮箱))
       (返回 (成功 "重置邮件已发送")))
      
      ;; 默认情况
      (否则
       (返回 (失败 "不支持的请求类型"))))))
       
(模块 购物车系统
  "管理用户的购物车操作"
  
  (定义 添加商品到购物车
    "将商品添加到指定用户的购物车"
    (参数 (用户ID 整数) (商品ID 整数) (数量 整数))
    
    (执行
      "检查商品库存"
      (设置 库存 (获取库存 商品ID))
      (如果 (< 库存 数量)
            (返回 (失败 "库存不足")))
      
      "获取用户当前购物车"
      (设置 购物车 (获取购物车 用户ID))
      
      "更新购物车"
      (设置 新购物车
            (更新购物车 购物车 商品ID 数量))
      
      "保存更新后的购物车"
      (保存购物车 用户ID 新购物车)
      
      "返回成功结果"
      (返回 (成功 "商品已添加到购物车"))))
  
  (定义 计算购物车总价
    "计算购物车中所有商品的总价格"
    (参数 (购物车 结构))
    
    (执行
      "提取购物车中的商品列表"
      (设置 商品列表 购物车.商品)
      
      "计算每个商品的小计"
      (设置 小计列表
            (映射 (λ (商品)
                    (* 商品.数量 商品.单价))
                  商品列表))
      
      "计算总价"
      (设置 总价 (求和 小计列表))
      
      "应用折扣"
      (设置 折扣后价格
            (应用折扣 总价 购物车.用户等级))
      
      "计算运费"
      (设置 最终价格
            (+ 折扣后价格
               (计算运费 购物车.总重量)))
      
      "返回价格详情"
      (返回 (价格详情
              原价 总价
              折扣金额 (- 总价 折扣后价格)
              运费 (计算运费 购物车.总重量)
              最终价格 最终价格)))))
              
(定义 创建订单
  "处理用户下单，包含完整校验和业务逻辑"
  (参数 (用户ID 整数) (购物车ID 整数) (收货地址 字符串))
  
  (执行流程
    ;; 阶段1：验证阶段
    (阶段 "验证数据"
      "检查用户是否存在"
      (如果 (非 (用户存在? 用户ID))
            (失败 "用户不存在"))
      
      "检查购物车是否为空"
      (如果 (购物车为空? 购物车ID)
            (失败 "购物车为空"))
      
      "验证收货地址有效性"
      (如果 (地址无效? 收货地址)
            (失败 "收货地址无效")))
    
    ;; 阶段2：计算阶段
    (阶段 "计算价格"
      "获取购物车内容"
      (设置 购物车内容 (获取购物车内容 购物车ID))
      
      "计算商品总价"
      (设置 价格详情 (计算购物车总价 购物车内容))
      
      "检查用户余额"
      (如果 (< (用户余额 用户ID) 价格详情.最终价格)
            (失败 "余额不足")))
    
    ;; 阶段3：处理阶段
    (阶段 "处理订单"
      "开始事务处理"
      (数据库事务
        "创建订单记录"
        (设置 订单号 (生成订单号))
        (创建订单记录 订单号 用户ID 购物车内容 价格详情 收货地址)
        
        "扣减库存"
        (每个 商品 在 购物车内容.商品
          (减少库存 商品.ID 商品.数量))
        
        "扣减用户余额"
        (减少余额 用户ID 价格详情.最终价格))
      
      "清空购物车"
      (清空购物车 购物车ID)
      
      "发送订单确认通知"
      (异步
        (发送订单确认邮件 用户ID 订单号)
        (通知仓库发货 订单号 收货地址)))
    
    ;; 返回结果
    (返回 (成功 订单号))))
    
(定义 分析销售数据
  "分析销售数据，生成统计报告"
  (参数 (原始数据 列表))
  
  (执行
    "数据清洗和转换管道"
    (设置 处理后的数据
          (管道 原始数据
                ;; 第一步：过滤无效数据
                (过滤 (λ (记录) 
                        (并且 (记录有效? 记录)
                              (> 记录.金额 0))))
                
                ;; 第二步：按日期分组
                (按 .日期 分组)
                
                ;; 第三步：每日统计
                (映射-值 (λ (每日记录)
                           (结构
                            日期 (第一项 每日记录).日期
                            总销售额 (求和 .金额)
                            订单数量 (长度)
                            平均订单额 (/ (求和 .金额) (长度))
                            最畅销商品 (找最大值 .商品ID (计数 .商品ID)))))))
    
    "生成月度汇总"
    (设置 月度汇总
          (分组-按 月份 处理后的数据
            (映射-值 (λ (月数据)
                       (结构
                        月份 月.月份
                        月销售额 (求和 .总销售额)
                        平均日销售额 (/ (求和 .总销售额) (长度 月数据))
                        增长趋势 (计算趋势 月数据))))))
    
    "返回分析结果"
    (返回 (分析报告
            每日明细 处理后的数据
            月度汇总 月度汇总
            洞察 (生成洞察 处理后的数据)))))
(定义 处理支付结果
  "根据支付结果执行不同操作"
  (参数 (支付结果 结构))
  
  (执行
    "解构支付结果并处理"
    (匹配 支付结果
      ;; 成功支付
      ((结构 状态 "成功" 交易号 交易号 金额 金额)
       "记录成功交易"
       (记录交易 交易号 金额 "成功")
       (更新订单状态 支付结果.订单号 "已支付")
       (返回 "支付成功"))
      
      ;; 失败支付
      ((结构 状态 "失败" 原因 原因)
       "记录失败原因"
       (记录失败 支付结果.订单号 原因)
       (通知用户 "支付失败" 原因)
       (返回 "支付失败"))
      
      ;; 待处理支付
      ((结构 状态 "待处理" 超时时间 时间)
       "设置定时检查"
       (设置定时器 时间
                   (检查支付状态 支付结果.订单号))
       (返回 "支付处理中"))
      
      ;; 其他情况
      (否则
       (记录错误 "未知支付状态" 支付结果)
       (返回 "系统错误")))))
       
(定义 批量处理用户任务
  "并行处理多个用户任务，合并结果"
  (参数 (用户列表 列表) (任务 函数))
  
  (执行
    "并行执行任务"
    (设置 所有结果
          (并行-映射 任务 用户列表))
    
    "收集成功结果"
    (设置 成功结果
          (过滤 (λ (结果) (结果成功? 结果))
                所有结果))
    
    "收集失败结果"
    (设置 失败结果
          (过滤 (λ (结果) (结果失败? 结果))
                所有结果))
    
    "生成汇总报告"
    (返回 (批量处理报告
            总任务数 (长度 用户列表)
            成功数 (长度 成功结果)
            失败数 (长度 失败结果)
            失败详情 (映射 .错误信息 失败结果)))))
            
(定义 可靠数据获取
  "获取数据，支持失败重试和降级策略"
  (参数 (数据源 字符串) (参数 列表))
  
  (执行
    "带重试的数据获取"
    (尝试
      (重试 3 ;; 重试次数
        (延迟 1000) ;; 重试间隔
        "从主数据源获取数据"
        (获取数据 数据源 参数))
      
      ;; 主数据源失败时
      (捕获 网络错误
        "尝试从备用数据源获取"
        (设置 备用数据 (从备用源获取 参数))
        (如果 备用数据
              (返回 备用数据)
              (抛出 "所有数据源均失败")))
      
      ;; 最终处理
      (最终
        "清理资源"
        (关闭连接 数据源)))))

(模块 测试套件
  "定义测试用例和断言"
  
  (测试 "用户注册功能测试"
    (描述 "测试用户注册的各种场景")
    
    (测试用例 "正常注册"
      (给定
        (用户名 "测试用户")
        (邮箱 "test@example.com")
        (密码 "SecurePass123"))
      
      (当
        (结果 (注册用户 用户名 邮箱 密码)))
      
      (那么
        (断言 (结果成功? 结果) #真)
        (断言 (包含? 结果.消息 "成功") #真)))
    
    (测试用例 "重复用户名注册"
      (给定
        (已有用户 (创建用户 "测试用户" "exist@test.com" "pass"))
        (新用户 (用户名 "测试用户") (邮箱 "new@test.com") (密码 "pass")))
      
      (那么-期待-错误
        (注册用户 新用户.用户名 新用户.邮箱 新用户.密码)
        "用户名已被使用")))
  
  (测试 "购物车计算测试"
    (描述 "测试购物车价格计算逻辑")
    
    (测试用例 "空购物车价格为零"
      (给定 (空购物车 (创建购物车)))
      
      (当 (价格 (计算购物车总价 空购物车)))
      
      (那么 (断言 (= 价格.最终价格 0) #真)))
    
    (测试用例 "多商品价格计算"
      (给定
        (购物车 (添加商品 空购物车 商品1 数量2)
                (添加商品 空购物车 商品2 数量1)))
      
      (那么
        (断言 (> 价格.最终价格 0) #真)
        (断言 (= 价格.原价 (+ (* 2 商品1.单价) 商品2.单价)) #真))))))
```

协作示例,    
产品需求输入,    
```bash
"用户登录要支持多种方式：密码登录、验证码登录、第三方登录。
登录后要记录日志，更新最后登录时间，根据用户等级显示不同界面。"
```

AI生成的函数式语义代码,    
```lisp
(模块 用户登录系统
  "处理用户登录，支持多种登录方式"
  
  (定义 处理登录请求
    "根据登录类型执行相应登录逻辑"
    (参数 (登录请求 结构))
    
    (执行
      "匹配登录类型"
      (匹配 登录请求.类型
        ;; 密码登录
        ((等于 "密码登录")
         "验证用户名和密码"
         (如果 (验证密码 登录请求.用户名 登录请求.密码)
               (登录成功 登录请求.用户名)
               (返回 "密码错误")))
        
        ;; 验证码登录
        ((等于 "验证码登录")
         "验证手机号和验证码"
         (如果 (验证验证码 登录请求.手机号 登录请求.验证码)
               (登录成功 (通过手机号获取用户名 登录请求.手机号))
               (返回 "验证码错误")))
        
        ;; 第三方登录
        ((等于 "第三方登录")
         "验证第三方授权"
         (设置 用户信息 (验证第三方授权 登录请求.平台 登录请求.授权码))
         (如果 用户信息
               (登录成功 用户信息.用户名)
               (返回 "第三方授权失败")))
        
        ;; 未知类型
        (否则 (返回 "不支持的登录类型")))))
  
  (定义 登录成功
    "用户登录成功后的统一处理"
    (参数 (用户名 字符串))
    
    (执行
      "异步执行后续操作"
      (异步
        "记录登录日志"
        (记录日志 "用户登录" 用户名 (当前时间))
        
        "更新最后登录时间"
        (更新用户信息 用户名 (最后登录时间 (当前时间)))
        
        "发送登录通知"
        (如果 (新设备登录? 用户名)
              (发送安全通知 用户名 "新设备登录"))))
    
    "根据用户等级返回不同界面配置"
    (设置 用户等级 (获取用户等级 用户名))
    (返回 (登录结果
            成功 #真
            用户名 用户名
            用户等级 用户等级
            界面配置 (获取界面配置 用户等级)
            权限列表 (获取用户权限 用户名))))))
```

这种风格既保留了函数式精髓，又融入了自然语言的易读型，形成了独特的"可执行文档"风格，特别适合人机协作。    

---

# 丁1:    

```lisp
;; ============================================================
;; 模块：用户认证服务
;; ── 版本 2.3.1 | 安全等级 P1 | 可观测性：高
;; ============================================================
(module 用户认证
  ;; ──────────────────────────────────────────────────────────
  ;; 依赖：效应系统自动注入版本与配置
  ;; ──────────────────────────────────────────────────────────
  (import 缓存 :from "@infra/redis" :version "4.1")
  (import 审计 :from "@compliance/audit" :version "1.8")

  ;; ──────────────────────────────────────────────────────────
  ;; 类型约束：静态分析与动态校验统一
  ;; ──────────────────────────────────────────────────────────
  (define-type 用户名 
    (符合正则 "^[a-zA-Z0-9_]+$" 且 长度在 3 到 20 之间))
  
  (define-type 密码
    (熵值大于 50 且 不在常见密码列表中))

  ;; ──────────────────────────────────────────────────────────
  ;; 纯函数：无副作用，可缓存，可并发
  ;; ──────────────────────────────────────────────────────────
  (defun 校验凭证格式 (用户名 密码) -> (要么 真 格式错误)
    "验证输入是否满足基本格式要求"
    (匹配 (列表 用户名 密码)
      [(用户名 为空) (格式错误 "用户名不能为空")]
      [(密码 长度小于 6) (格式错误 "密码太短")]
      [_ (成功 真)]))  ; 通配符，返回成功

  ;; ──────────────────────────────────────────────────────────
  ;; 不纯函数：显式声明效应
  ;; ──────────────────────────────────────────────────────────
  (defun 查询用户! (用户名) -> (可选 用户记录)
    "带缓存的用户查询，效应：数据库读取 + 缓存写入"
    (效应
      (数据库 查询)
      (缓存 读取/写入)
      (审计 读操作日志))
    
    (let*  ; 按顺序绑定，每个绑定可见后续
          [(缓存键 (字符串拼接 "user:" 用户名))
           (缓存结果 (缓存.获取 缓存键))]
      (如果 (存在? 缓存结果)
        (成功 缓存结果)  ; 缓存命中
        (let [(数据库结果 (数据库.执行 "SELECT * FROM users WHERE username = ?" 用户名))]
          (匹配 数据库结果
            [(为空) (返回 无)]  ; 用户不存在
            [用户 (do
                    (缓存.设置 缓存键 用户 :过期 5分钟)
                    (成功 用户))])))))

  ;; ──────────────────────────────────────────────────────────
  ;; 高阶函数：接收验证策略作为参数
  ;; ──────────────────────────────────────────────────────────
  (defun 重试验证! (验证函数 最大次数) -> (函数)
    "返回一个带重试逻辑的新函数，效应：副作用累积"
    (lambda (输入)
      (循环 ((剩余次数 最大次数) (上次错误 无))
        (如果 (<= 剩余次数 0)
          (失败 上次错误)  ; 耗尽次数，返回最后的错误
          
          (匹配 (验证函数 输入)
            [(成功 结果) (成功 结果)]
            [(失败 原因) 
             (审计.记录 "验证失败" :原因 原因 :剩余次数 剩余次数)
             (继续 (- 剩余次数 1) 原因)])))))  ; 递归重试

  ;; ──────────────────────────────────────────────────────────
  ;; 主函数：组合子模式，声明式流程
  ;; ──────────────────────────────────────────────────────────
  (defun 认证! (用户名 密码) -> (要么 令牌 认证错误)
    "完整的认证流程，效应：读数据库、写缓存、记审计、发指标"
    (效应
      (数据库 读)
      (缓存 读/写/删除)
      (审计 写)
      (监控 指标上报))
    
    (管道
      ;; 阶段1：格式校验（纯函数，可短路）
      (校验凭证格式 用户名 密码)
      
      ;; 阶段2：限流检查（不纯，可能抛出异常）
      (λ (中间结果)
        (如果 (被限流? 客户端IP)
          (认证错误 "请求过于频繁")
          (成功 中间结果)))
      
      ;; 阶段3：用户查询（带缓存）
      (λ (_) (查询用户! 用户名))
      
      ;; 阶段4：密码比对（固定时间算法）
      (λ (用户)
        (匹配 (密码.固定时间比对 密码 用户.password_hash)
          [真 (成功 用户)]
          [假 (认证错误 "凭证无效")]))
      
      ;; 阶段5：成功后处理（并行效应）
      (λ (用户)
        (并发执行
          (审计.记录 "登录成功" :用户ID 用户.id)
          (监控.递增 "auth.success")
          (缓存.删除 (字符串拼接 "rate_limit:" 客户端IP)))
        (成功 (令牌.生成 用户.id :过期时间 "24h")))))
  
  ;; ──────────────────────────────────────────────────────────
  ;; 辅助函数：限流判定
  ;; ──────────────────────────────────────────────────────────
  (defun 被限流? (IP地址) -> 布尔值
    "检查IP是否超过请求阈值，效应：缓存读取"
    (效应 (缓存 读))
    
    (let [(次数 (缓存.自增 (字符串拼接 "rate_limit:" IP地址) :过期 1小时))]
      (> 次数 10)))  ; 阈值配置可外部注入

  ;; ──────────────────────────────────────────────────────────
  ;; 测试契约：测试即函数式规约
  ;; ──────────────────────────────────────────────────────────
  (defproperty 认证幂等性
    "相同凭证多次认证应返回相同令牌（缓存一致）"
    ;; 属性：纯函数行为的声明
    (对所有 (用户名 密码)
      (匹配 (列表 (认证! 用户名 密码) (认证! 用户名 密码))
        [(成功 令牌1) (成功 令牌2)] (= 令牌1 令牌2)]
        [(失败 错误1) (失败 错误2)] (= 错误1 错误2)])))

  (deftest 认证测试套件
    (测试用例 "正常登录"
      :前提 (模拟 数据库) :返回 测试用户
      :动作 (认证! "alice" "正确的密码")
      :期望 (成功 令牌)
      :并确保 (审计.记录已被调用 :事件 "登录成功"))
    
    (测试用例 "密码错误触发限流"
      :动作 (重复 5 (认证! "bob" "错误密码"))
      :期望 (列表 (全部 失败) (理由 "凭证无效"))
      :副作用 (监控.指标 "auth.failure" 等于 5))
    
    (测试用例 "第六次登录应锁定账户"
      :前提 (模拟 缓存.获取 "rate_limit:bob" :返回 6)
      :动作 (认证! "bob" "任意密码")
      :期望 (失败 (认证错误 "请求过于频繁")))))

;; ============================================================
;; 工作流：创建文章（组合多个效应函数）
;; ── 展示函数式编排：Monad风格或Effect Row
;; ============================================================
(workflow 创建文章
  ;; 输入Schema
  (输入 (标题 字符串 长度5到100 必填)
        (内容 Markdown 最大10000)
        (标签 列表<字符串> 最多5个)
        (草稿? 布尔 默认#f))

  ;; 环境读取：依赖注入的函数式风格
  (环境 (当前用户 (从请求头 "X-User-Token"))
        (客户端IP (从上下文 "client-ip")))

  ;; 主流程：Kleisli组合（伪造货→函数式效应流）
  (流程 (组合
         认证用户!          ; Either 令牌 错误
         检查权限!          ; 需要令牌，返回是否有权限
         校验内容!          ; 需要内容和权限，返回校验结果
         保存数据库!        ; Saga事务，返回文章ID
         发送通知!))        ; 副作用，返回空

  ;; 错误处理：函数式的Either模式匹配
  (错误处理
    (左边 错误
      (匹配 错误
        [(权限不足) (返回 403 :消息 "您无法在此分类下发布")]
        [(内容违规 原因) (返回 400 :消息 原因)]
        [其他 (返回 500 :消息 "系统繁忙")]))
    
    (右边 结果
      (返回 成功 :文章ID 结果.ID :链接 (路由.生成 "/posts/{}" 结果.ID))))

  ;; 遥测：纯函数式追踪
  (遥测 (让* [(开始时间 (当前时间))]
          (监控.记录耗时 "workflow.create_post" (- (当前时间) 开始时间))
          (追踪.结束跨度 "create-post"))))
```

大模型如何"写"这种代码?    
人类：用户登录要加人机验证，不是图形验证码，是reCAPTCHA v3,    
```lisp
;; diff：在步骤2插入新验证
(流程 (组合
       校验凭证格式
+      (λ (_)
+        (require (reCAPTCHA.验证 (从请求头 "X-Recaptcha-Token") :动作 "login")
+                 :阈值 0.7
+                 :失败时 (认证错误 "人机验证失败")))
       查询用户!
       比对密码!))
```

人类Review：阈值改成0.6，失败记审计,    
```lisp
(reCAPTCHA.验证 ... 
+ :阈值 0.6
+ :失败时 (do (审计.记录 "reCAPTCHA失败" :分数 分数)
+             (认证错误 "人机验证失败")))
```


---

# 丁2:    

```python
关于 待办事项管理：

  当 创建任务 时，用 标题 做：
    若 标题 为空：
      返回 失败(原因: "标题不能为空")
    否则：
      新任务 = 构造任务(
        ID: 生成唯一ID(),
        标题: 标题,
        状态: "未完成",
        时间: 当前时间()
      )
      存储任务(新任务)
      返回 成功(数据: 新任务)

  当 查询所有任务 时，用 无参数 做：
    从 任务库
      → 获取全部
      → 按 时间 降序排列
      → 返回 成功(数据: 列表)

  当 更新任务状态 时，用 任务ID 和 新状态 做：
    尝试 查找任务(任务ID)：
      成功时 → 任务：
        更新任务(任务, 状态: 新状态)
        返回 成功(数据: 任务)
      失败时 → 错误：
        返回 失败(原因: "任务不存在")

  当 删除任务 时，用 任务ID 做：
    若 任务存在(任务ID)：
      从 任务库 移除 任务ID
      返回 成功(消息: "已删除")
    否则：
      返回 失败(原因: "任务不存在")

  内部 辅助函数：
    - 生成唯一ID()：返回 全局计数器自增
    - 构造任务(...)：返回 不可变记录
    - 存储任务(任务)：写入内存映射表
```

人类说：“用户删任务时，要确保存在再删”    
→ AI 自动映射为    

```python
当 删除任务 时，用 ID 做：
  若 任务存在(ID)：执行删除；否则：返回错误
```

无需关心变量声明、内存管理、异常栈——只表达意图与规则。    
大模型可将 当...时 翻译为函数，尝试 翻译为 Result<T, E> 类型（Rust）或 Either（Haskell）。    

这使得 [`提示字编程语言`] 既是人类可读的 PRD，又是AI 可精确解释/翻译的中间表示（IR）。    
```python
关于 用户账户系统：

  当 注册新用户 时，用 邮箱 和 密码 做：
    若 邮箱 格式无效：
      返回 失败(原因: "邮箱格式不正确")
    若 密码 强度不足（长度 < 8）：
      返回 失败(原因: "密码至少8位")
    若 账户已存在(邮箱)：
      返回 失败(原因: "该邮箱已注册")

    新用户 = 构造未验证用户(
      邮箱: 邮箱,
      密码哈希: 哈希加盐(密码),
      验证令牌: 生成随机令牌(),
      创建时间: 当前时间(),
      状态: "待验证"
    )

    存储用户(新用户)

    尝试 发送验证邮件(
      收件人: 邮箱,
      令牌: 新用户.验证令牌,
      有效期: 24小时
    )：
      成功时 → _：
        返回 成功(消息: "注册成功，请查收验证邮件", 数据: { 邮箱: 邮箱 })
      失败时 → 错误：
        // 注意：用户已存，但邮件失败 → 可重发
        返回 成功(消息: "注册成功，但邮件发送失败，请稍后重试", 数据: { 邮箱: 邮箱, 可重发: 真 })


  当 验证邮箱 时，用 邮箱 和 令牌 做：
    用户 = 查找未验证用户(邮箱)

    若 用户 为空：
      返回 失败(原因: "无效邮箱或已验证")

    若 用户.验证令牌 ≠ 令牌：
      返回 失败(原因: "验证链接无效")

    若 当前时间() - 用户.创建时间 > 24小时：
      删除用户(邮箱)
      返回 失败(原因: "验证链接已过期")

    激活用户 = 更新用户状态(
      用户,
      状态: "已激活",
      验证时间: 当前时间(),
      验证令牌: 空  // 清除令牌，防止重复使用
    )

    存储用户(激活用户)
    返回 成功(消息: "账户已激活，欢迎使用！")


  当 重发验证邮件 时，用 邮箱 做：
    用户 = 查找未验证用户(邮箱)

    若 用户 为空：
      返回 失败(原因: "该邮箱未注册或已激活")

    若 当前时间() - 用户.创建时间 > 24小时：
      删除用户(邮箱)
      返回 失败(原因: "注册已过期，请重新注册")

    新令牌 = 生成随机令牌()
    更新后用户 = 更新用户字段(用户, 验证令牌: 新令牌)

    存储用户(更新后用户)

    尝试 发送验证邮件(邮箱, 新令牌, 24小时)：
      成功时 → _：
        返回 成功(消息: "验证邮件已重发")
      失败时 → _：
        返回 失败(原因: "邮件服务暂时不可用")


  内部 辅助函数：
    - 账户已存在(邮箱)：
        返回 (查找用户(邮箱) ≠ 空)

    - 查找未验证用户(邮箱)：
        用户 = 查找用户(邮箱)
        若 用户 且 用户.状态 == "待验证"：
          返回 用户
        否则：
          返回 空

    - 定时清理过期注册()：
        从 所有用户
          → 过滤 (用户.状态 == "待验证" 且 当前时间() - 用户.创建时间 > 24小时)
          → 映射 (删除用户(用户.邮箱))
        // 此函数由系统后台每日调用
```

这种写法，产品经理可读、开发者可审、AI 可翻译，且天然具备高内聚、低耦合、易测试的函数式优势。    

---


编译到多目标的幻觉示例;    
```bash
# 编译为生产级Python
promptir-compile UserAuth.promptir --target=python --output=auth.py
# 生成：带async/await、typing、decorator、prometheus指标的代码

# 编译为Go微服务
promptir-compile UserAuth.promptir --target=go --output=user_service/
# 生成：interface、error wrapping、context超时、otel tracing

# 编译为PRD文档
promptir-compile UserAuth.promptir --target=prddoc --output=auth_prd.md
# 生成：用例图、时序图、边界条件表格、SLA定义

# 编译为测试套件
promptir-compile UserAuth.promptir --target=pytest --output=test_auth.py
# 生成：参数化测试、mock fixture、性能基准测试

promptir-compile --target=python auth.promptir
;; 生成：自动插入验证码SDK调用、异步校验、重试逻辑

```

终极形态：PromptIR REPL    
```lisp
> (load "UserAuth.promptir")
> (test-run 'UserAuth:authenticate 
    :mock '((db:query . ,(lambda () fake-user))))
;; 立即在REPL中测试语义，无需生成代码
```

Lisp风格的PromptIR，让 意图既是代码，又是可演化的数据 ——大模型不是在"写代码"，    
而是在 "操作AST" ，人类审查的是 "可执行的架构蓝图" 。    


> https://chat.deepseek.com/share/q6223u1uc0zbr25j2u ,

> https://www.kimi.com/share/19adc8b5-01e2-8310-8000-0000e93560ea ,

