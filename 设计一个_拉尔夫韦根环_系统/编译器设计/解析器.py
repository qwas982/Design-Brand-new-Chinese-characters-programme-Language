"""
解析器模块 - 语法分析器实现
本模块实现增强的递归下降解析器，使用ADT和模式匹配
"""

from typing import List, Optional, Dict, Any, Callable
from dataclasses import dataclass, field

# 导入共享类型
from 异常处理 import (
    异常处理中心, 错误节点, 错误类型, 错误级别,
    语法分析异常
)
from 代数数据类型ADT import (
    可选, 要么,
    词法单元, 词法单元基类,
    关键字词法单元, 标识符词法单元,
    数字词法单元, 浮点数词法单元, 字符串词法单元,
    运算符词法单元, 分隔符词法单元, 文件结束词法单元,
    AST节点基类, 程序节点, 循环节点, 验证节点,
    持久化节点, AI调用节点, 条件节点, 块节点,
    表达式节点基类, 字面量节点, 标识符节点,
    二元表达式节点, 一元表达式节点, 函数调用节点,
    变量声明节点, 赋值节点,
    指令
)


@dataclass
class 解析器配置:
    """解析器配置"""
    是否启用错误恢复: bool = True
    是否记录解析树: bool = False
    关键字集合: set = field(default_factory=lambda: {
        "循环", "验证", "持久化", "调用AI", "如果", "否则", "结束",
        "定义", "变量", "函数", "返回", "真", "假", "空"
    })


class 增强递归下降解析器:
    """
    增强的递归下降解析器 - 使用ADT和模式匹配
    维护一个解析栈用于跟踪解析状态
    
    算法思路：
    1. 使用预测分析表指导解析过程
    2. 使用栈跟踪非终结符的解析状态
    3. 使用模式匹配处理不同产生式
    4. 维护错误栈和恢复树
    """
    
    def __init__(self, 词法单元列表: List[词法单元] = None, 配置: 解析器配置 = None):
        self.词法单元列表 = 词法单元列表 or []
        self.配置 = 配置 or 解析器配置()
        
        # 当前位置
        self.当前位置 = 0
        
        # 异常处理
        self.异常处理中心 = 异常处理中心()
        
        # 符号表（用于语义分析）
        self.符号表: Dict[str, Dict] = {}
        
        # 优先级表（用于表达式解析）
        self._运算符优先级 = {
            "||": 1,
            "&&": 2,
            "==": 3, "!=": 3,
            "<": 4, "<=": 4, ">": 4, ">=": 4,
            "+": 5, "-": 5,
            "*": 6, "/": 6, "%": 6,
            "unary": 7  # 一元运算符
        }
        
        # 运算符结合性
        self._右结合运算符 = {"==", "!=", "<", "<=", ">", ">=", "+", "-", "*", "/", "%"}
    
    def 设置词法单元列表(self, 词法单元列表: List[词法单元]):
        """设置词法单元列表"""
        self.词法单元列表 = list(词法单元列表)
        self.当前位置 = 0
        self.异常处理中心.清除错误记录()
    
    def 解析(self) -> 可选[程序节点]:
        """
        语法分析主函数
        
        伪代码：
        1. 初始化解析状态
        2. 构建程序根节点
        3. 循环解析语句直到文件结束
        4. 返回AST或错误
        
        返回:
            可选的程序节点（AST根节点）
        """
        if not self.词法单元列表:
            self.异常处理中心.创建错误节点(
                错误信息="词法单元列表为空",
                行号=0, 列号=0, 错误类型=错误类型.语法错误
            )
            return 可选()
        
        # 创建程序根节点
        程序根节点 = 程序节点(
            语句列表=[],
            位置信息={"行号": 1, "列号": 1}
        )
        
        # 解析语句列表
        while not self._是否到达文件末尾():
            语句 = self._解析语句()
            
            if 语句 is not None:
                程序根节点.语句列表.append(语句)
            else:
                # 解析失败，尝试恢复
                if self.配置.是否启用错误恢复:
                    self._恐慌模式恢复()
                else:
                    break
        
        # 检查是否有错误
        if self.异常处理中心.有错误():
            return 可选()
        
        return 可选(程序根节点)
    
    def _解析语句(self) -> Optional[AST节点基类]:
        """解析语句"""
        当前词法单元 = self._当前词法单元()
        
        # 跳过分隔符
        if isinstance(当前词法单元, 分隔符词法单元) and 当前词法单元.值 in ";,":
            self._消耗词法单元()
            return self._解析语句()
        
        # 空语句检查
        if self._是否文件结束():
            return None
        
        # 模式匹配处理不同语句类型
        匹配结果 = self._匹配关键字语句(当前词法单元)
        if 匹配结果 is not None:
            return 匹配结果
        
        # 尝试解析表达式语句
        return self._解析表达式语句()
    
    def _匹配关键字语句(self, 当前词法单元) -> Optional[AST节点基类]:
        """根据关键字匹配语句类型"""
        if isinstance(当前词法单元, 关键字词法单元):
            值 = 当前词法单元.值
            
            if 值 == "循环":
                return self._解析循环语句()
            elif 值 == "验证":
                return self._解析验证语句()
            elif 值 == "持久化":
                return self._解析持久化语句()
            elif 值 == "调用AI":
                return self._解析AI调用语句()
            elif 值 == "如果":
                return self._解析条件语句()
            elif 值 == "定义":
                return self._解析变量声明语句()
            elif 值 == "变量":
                return self._解析变量声明语句()
        
        return None
    
    def _解析循环语句(self) -> Optional[循环节点]:
        """解析循环语句：循环 次数: ... 结束"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        # 消耗"循环"关键字
        self._消耗词法单元()
        
        # 解析循环次数表达式
        循环次数 = self._解析表达式()
        if 循环次数 is None:
            self._记录语法错误("期待循环次数表达式")
            循环次数 = 字面量节点(值=1, 类型="整数", 位置信息={"行号": 行号, "列号": 列号})
        
        # 消耗冒号
        self._消耗分隔符(":")
        
        # 解析循环体
        循环体 = self._解析块节点("循环")
        
        if 循环体 is None:
            self._记录语法错误("期待循环体")
            循环体 = 块节点(语句列表=[], 位置信息={"行号": 行号, "列号": 列号})
        
        # 消耗"结束"关键字
        self._消耗关键字("结束")
        
        return 循环节点(
            循环次数=循环次数,
            循环体=循环体,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析验证语句(self) -> Optional[验证节点]:
        """解析验证语句：验证 命令"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        # 消耗"验证"关键字
        self._消耗词法单元()
        
        # 解析验证命令表达式
        验证命令 = self._解析表达式()
        if 验证命令 is None:
            self._记录语法错误("期待验证命令表达式")
            验证命令 = 字面量节点(值="echo test", 类型="字符串")
        
        return 验证节点(
            验证命令=验证命令,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析持久化语句(self) -> Optional[持久化节点]:
        """解析持久化语句：持久化 [路径]"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        # 消耗"持久化"关键字
        self._消耗词法单元()
        
        # 可选：解析路径表达式
        路径表达式 = None
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 字符串词法单元) or isinstance(当前词法单元, 标识符词法单元):
            路径表达式 = self._解析基本表达式()
        
        return 持久化节点(
            路径表达式=路径表达式,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析AI调用语句(self) -> Optional[AI调用节点]:
        """解析AI调用语句：调用AI 任务描述"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        # 消耗"调用AI"关键字
        self._消耗词法单元()
        
        # 解析任务描述表达式
        任务描述 = self._解析表达式()
        if 任务描述 is None:
            self._记录语法错误("期待任务描述表达式")
            任务描述 = 字面量节点(值="请完成这个任务", 类型="字符串")
        
        return AI调用节点(
            任务描述=任务描述,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析条件语句(self) -> Optional[条件节点]:
        """解析条件语句：如果 条件: ... [否则: ...] 结束"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        # 消耗"如果"关键字
        self._消耗词法单元()
        
        # 解析条件表达式
        条件表达式 = self._解析表达式()
        if 条件表达式 is None:
            self._记录语法错误("期待条件表达式")
            条件表达式 = 字面量节点(值=True, 类型="布尔值")
        
        # 消耗冒号
        self._消耗分隔符(":")
        
        # 解析真分支
        真分支 = self._解析块节点("条件")
        
        # 解析假分支（如果有）
        假分支 = None
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 关键字词法单元) and 当前词法单元.值 == "否则":
            self._消耗词法单元()
            self._消耗分隔符(":")
            假分支 = self._解析块节点("否则分支")
        
        # 消耗"结束"关键字
        self._消耗关键字("结束")
        
        return 条件节点(
            条件表达式=条件表达式,
            真分支=真分支,
            假分支=假分支,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析变量声明语句(self) -> Optional[变量声明节点]:
        """解析变量声明语句：定义 变量名 = 值 或 变量 变量名 = 值"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        # 消耗"定义"或"变量"关键字
        关键字 = self._当前词法单元().值
        self._消耗词法单元()
        
        # 解析变量名
        变量名 = None
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 标识符词法单元):
            变量名 = 当前词法单元.值
            self._消耗词法单元()
        else:
            self._记录语法错误("期待变量名")
            return None
        
        # 解析初始值（可选）
        初始值 = None
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 运算符词法单元) and 当前词法单元.值 == "=":
            self._消耗词法单元()
            初始值 = self._解析表达式()
        
        # 注册到符号表
        self.符号表[变量名] = {"类型": "变量", "声明行": 行号}
        
        return 变量声明节点(
            变量名=变量名,
            初始值=初始值,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析块节点(self, 块名称: str) -> Optional[块节点]:
        """解析块节点：语句列表"""
        行号 = self._当前行号()
        列号 = self._当前列号()
        
        语句列表: List[AST节点基类] = []
        
        while not self._是否到达文件末尾():
            当前词法单元 = self._当前词法单元()
            
            # 检查是否遇到"结束"或"否则"
            if isinstance(当前词法单元, 关键字词法单元):
                if 当前词法单元.值 == "结束":
                    break
                if 当前词法单元.值 == "否则" and 块名称 in ["条件", "否则分支"]:
                    break
            
            # 解析语句
            语句 = self._解析语句()
            if 语句 is not None:
                语句列表.append(语句)
            else:
                # 解析失败，尝试恢复
                if self.配置.是否启用错误恢复:
                    self._恐慌模式恢复()
                else:
                    break
        
        return 块节点(
            语句列表=语句列表,
            位置信息={"行号": 行号, "列号": 列号}
        )
    
    def _解析表达式语句(self) -> Optional[AST节点基类]:
        """解析表达式语句"""
        表达式 = self._解析表达式()
        
        if 表达式 is not None:
            # 检查是否是赋值语句
            if isinstance(表达式, 标识符节点):
                当前词法单元 = self._当前词法单元()
                if isinstance(当前词法单元, 运算符词法单元) and 当前词法单元.值 == "=":
                    self._消耗词法单元()
                    右值 = self._解析表达式()
                    if 右值 is not None:
                        return 赋值节点(
                            变量名=表达式.名称,
                            值表达式=右值,
                            位置信息=表达式.位置信息
                        )
            
            return 表达式
        
        # 消耗无效的分隔符
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 分隔符词法单元):
            self._消耗词法单元()
        
        return None
    
    def _解析表达式(self) -> Optional[表达式节点基类]:
        """解析表达式 - 使用算符优先分析法"""
        return self._解析二元表达式(0)
    
    def _解析二元表达式(self, 最小优先级: int) -> Optional[表达式节点基类]:
        """解析二元表达式 - 递归下降"""
        # 解析左操作数
        左操作数 = self._解析一元表达式()
        if 左操作数 is None:
            return None
        
        while True:
            当前词法单元 = self._当前词法单元()
            
            if not isinstance(当前词法单元, 运算符词法单元):
                break
            
            运算符 = 当前词法单元.值
            优先级 = self._运算符优先级.get(运算符, 0)
            
            if 优先级 == 0 or 优先级 < 最小优先级:
                break
            
            # 确定下一优先级
            if 运算符 in self._右结合运算符:
                下一优先级 = 优先级
            else:
                下一优先级 = 优先级 + 1
            
            # 消耗运算符
            self._消耗词法单元()
            
            # 解析右操作数
            右操作数 = self._解析二元表达式(下一优先级)
            if 右操作数 is None:
                self._记录语法错误(f"运算符 {运算符} 期待右操作数")
                break
            
            # 构建二元表达式节点
            左操作数 = 二元表达式节点(
                左表达式=左操作数,
                运算符=运算符,
                右表达式=右操作数,
                位置信息=self._获取位置信息(左操作数)
            )
        
        return 左操作数
    
    def _解析一元表达式(self) -> Optional[表达式节点基类]:
        """解析一元表达式"""
        当前词法单元 = self._当前词法单元()
        
        # 检查一元运算符
        if isinstance(当前词法单元, 运算符词法单元):
            运算符 = 当前词法单元.值
            if 运算符 in ["-", "!", "not"]:
                self._消耗词法单元()
                操作数 = self._解析一元表达式()
                if 操作数 is not None:
                    return 一元表达式节点(
                        运算符=运算符,
                        表达式=操作数,
                        位置信息=self._获取位置信息(操作数)
                    )
        
        return self._解析基本表达式()
    
    def _解析基本表达式(self) -> Optional[表达式节点基类]:
        """解析基本表达式（字面量、标识符、括号）"""
        当前词法单元 = self._当前词法单元()
        
        # 数字字面量
        if isinstance(当前词法单元, 数字词法单元):
            值 = 当前词法单元.值
            self._消耗词法单元()
            return 字面量节点(
                值=值,
                类型="整数",
                位置信息=self._获取位置信息(当前词法单元)
            )
        
        # 浮点数字面量
        if isinstance(当前词法单元, 浮点数词法单元):
            值 = 当前词法单元.值
            self._消耗词法单元()
            return 字面量节点(
                值=值,
                类型="浮点数",
                位置信息=self._获取位置信息(当前词法单元)
            )
        
        # 字符串字面量
        if isinstance(当前词法单元, 字符串词法单元):
            值 = 当前词法单元.值
            self._消耗词法单元()
            return 字面量节点(
                值=值,
                类型="字符串",
                位置信息=self._获取位置信息(当前词法单元)
            )
        
        # 布尔值
        if isinstance(当前词法单元, 关键字词法单元):
            if 当前词法单元.值 in ["真", "假"]:
                值 = 当前词法单元.值 == "真"
                self._消耗词法单元()
                return 字面量节点(
                    值=值,
                    类型="布尔值",
                    位置信息=self._获取位置信息(当前词法单元)
                )
        
        # 标识符
        if isinstance(当前词法单元, 标识符词法单元):
            名称 = 当前词法单元.值
            行号 = 当前词法单元.行号
            列号 = 当前词法单元.列号
            self._消耗词法单元()
            
            # 检查是否是函数调用
            下一词法单元 = self._当前词法单元()
            if isinstance(下一词法单元, 分隔符词法单元) and 下一词法单元.值 == "(":
                self._消耗词法单元()  # 消耗 "("
                参数列表 = self._解析参数列表()
                self._消耗分隔符(")")  # 消耗 ")"
                return 函数调用节点(
                    函数名=名称,
                    参数列表=参数列表,
                    位置信息={"行号": 行号, "列号": 列号}
                )
            
            return 标识符节点(
                名称=名称,
                位置信息={"行号": 行号, "列号": 列号}
            )
        
        # 括号表达式
        if isinstance(当前词法单元, 分隔符词法单元) and 当前词法单元.值 == "(":
            self._消耗词法单元()
            表达式 = self._解析表达式()
            if 表达式 is not None:
                self._消耗分隔符(")")
                return 表达式
        
        return None
    
    def _解析参数列表(self) -> List[表达式节点基类]:
        """解析参数列表"""
        参数列表: List[表达式节点基类] = []
        
        # 检查空参数列表
        下一词法单元 = self._当前词法单元()
        if isinstance(下一词法单元, 分隔符词法单元) and 下一词法单元.值 == ")":
            return 参数列表
        
        # 解析第一个参数
        参数 = self._解析表达式()
        if 参数 is not None:
            参数列表.append(参数)
        
        # 解析剩余参数
        while True:
            下一词法单元 = self._当前词法单元()
            if not isinstance(下一词法单元, 分隔符词法单元) or 下一词法单元.值 != ",":
                break
            
            self._消耗词法单元()  # 消耗 ","
            参数 = self._解析表达式()
            if 参数 is not None:
                参数列表.append(参数)
            else:
                break
        
        return 参数列表
    
    # ============ 辅助方法 ============
    
    def _当前词法单元(self) -> 词法单元:
        """获取当前词法单元"""
        if self.当前位置 < len(self.词法单元列表):
            return self.词法单元列表[self.当前位置]
        return 文件结束词法单元(行号=0, 列号=0, 位置=len(self.词法单元列表))
    
    def _消耗词法单元(self):
        """消耗当前词法单元"""
        if not self._是否到达文件末尾():
            self.当前位置 += 1
    
    def _消耗关键字(self, 关键字: str) -> bool:
        """消耗指定关键字"""
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 关键字词法单元) and 当前词法单元.值 == 关键字:
            self._消耗词法单元()
            return True
        return False
    
    def _消耗分隔符(self, 分隔符: str) -> bool:
        """消耗指定分隔符"""
        当前词法单元 = self._当前词法单元()
        if isinstance(当前词法单元, 分隔符词法单元) and 当前词法单元.值 == 分隔符:
            self._消耗词法单元()
            return True
        return False
    
    def _是否到达文件末尾(self) -> bool:
        """检查是否到达文件末尾"""
        if self.当前位置 >= len(self.词法单元列表):
            return True
        当前单元 = self.词法单元列表[self.当前位置]
        return isinstance(当前单元, 文件结束词法单元)
    
    def _是否文件结束(self) -> bool:
        """检查当前词法单元是否是文件结束"""
        return isinstance(self._当前词法单元(), 文件结束词法单元)
    
    def _当前行号(self) -> int:
        """获取当前行号"""
        return self._当前词法单元().行号
    
    def _当前列号(self) -> int:
        """获取当前列号"""
        return self._当前词法单元().列号
    
    def _获取位置信息(self, 节点) -> Dict[str, int]:
        """获取节点的位置信息"""
        if hasattr(节点, '位置信息') and 节点.位置信息:
            return 节点.位置信息
        if hasattr(节点, '行号'):
            return {"行号": 节点.行号, "列号": 节点.列号}
        return {"行号": 0, "列号": 0}
    
    def _记录语法错误(self, 错误信息: str):
        """记录语法错误"""
        self.异常处理中心.创建错误节点(
            错误信息=错误信息,
            行号=self._当前行号(),
            列号=self._当前列号(),
            错误类型=错误类型.语法错误,
            严重程度=错误级别.错误
        )
    
    def _恐慌模式恢复(self):
        """恐慌模式错误恢复"""
        同步词集合 = {"循环", "验证", "持久化", "调用AI", "如果", "定义", "变量", "结束", "否则", "文件结束"}
        
        # 跳过词法单元直到同步词
        while (self.当前位置 < len(self.词法单元列表) and 
               not self._是否文件结束()):
            当前词法单元 = self._当前词法单元()
            
            # 检查是否是同步词
            if isinstance(当前词法单元, 关键字词法单元):
                if 当前词法单元.值 in 同步词集合:
                    break
            
            self._消耗词法单元()
    
    def 获取错误列表(self) -> List[错误节点]:
        """获取所有错误"""
        return self.异常处理中心.获取所有错误()
    
    def 有错误(self) -> bool:
        """检查是否有错误"""
        return self.异常处理中心.有错误()


# ============ 便捷函数 ============

def 解析(词法单元列表: List[词法单元]) -> 可选[程序节点]:
    """
    便捷解析函数
    
    参数:
        词法单元列表: 词法分析产生的词法单元列表
    
    返回:
        可选的程序节点（AST根节点）
    """
    解析器 = 增强递归下降解析器(词法单元列表)
    return 解析器.解析()


# ============ 测试代码 ============

if __name__ == "__main__":
    print("测试解析器")
    print("=" * 60)
    
    # 测试词法分析
    from 词法器 import 增强词法分析器
    
    测试代码 = """
循环 5:
    验证 "python test.py"
    如果 验证通过:
        持久化 "./结果.json"
    否则:
        调用AI "测试失败"
    结束
结束
"""
    
    print(f"测试代码:\n{测试代码}")
    print("=" * 60)
    
    # 词法分析
    词法分析器 = 增强词法分析器(测试代码)
    词法结果 = 词法分析器.分析()
    
    if 词法结果.是空():
        print("词法分析失败:")
        for 错误 in 词法分析器.获取错误列表():
            print(f"  行{错误.行号}, 列{错误.列号}: {错误.错误信息}")
    else:
        词法单元列表 = 词法结果.获取值()
        print(f"词法分析成功: {len(词法单元列表)} 个词法单元")
        
        # 语法分析
        解析器 = 增强递归下降解析器(词法单元列表)
        解析结果 = 解析器.解析()
        
        if 解析结果.是空():
            print("\n语法分析失败:")
            for 错误 in 解析器.获取错误列表():
                print(f"  行{错误.行号}, 列{错误.列号}: {错误.错误信息}")
        else:
            AST根节点 = 解析结果.获取值()
            print(f"\n语法分析成功!")
            print(f"程序包含 {len(AST根节点.语句列表)} 条语句")
            
            # 遍历AST
            def 遍历回调(节点):
                节点类型 = type(节点).__name__
                if hasattr(节点, '位置信息'):
                    行号 = 节点.位置信息.get("行号", 0)
                    print(f"  {节点类型} (行{行号})")
            
            AST根节点.遍历(遍历回调)
