"""
词法分析器模块 - 将源代码转换为词法单元序列
本模块实现增强的词法分析器，使用ADT和模式匹配
"""

import re
from typing import List, Dict, Any, Callable
from dataclasses import dataclass, field

# 导入共享类型和异常处理
from 异常处理 import (
    异常处理中心, 错误节点, 错误类型, 错误级别,
    词法分析异常, 语法分析异常
)
from 代数数据类型ADT import (
    可选,
    词法单元基类, 关键字词法单元, 标识符词法单元,
    数字词法单元, 浮点数词法单元, 字符串词法单元,
    运算符词法单元, 分隔符词法单元, 文件结束词法单元,
    注释词法单元, 词法单元
)


@dataclass
class 词法分析器配置:
    """词法分析器配置"""
    是否保留注释: bool = False
    是否区分大小写: bool = True  # 关键字是否区分大小写
    关键字列表: List[str] = field(default_factory=lambda: [
        "循环", "验证", "持久化", "调用AI", "如果", "否则", "结束",
        "定义", "变量", "函数", "返回", "真", "假", "空"
    ])
    运算符列表: List[str] = field(default_factory=lambda: [
        "==", "!=", "<=", ">=", "&&", "||", 
        "+", "-", "*", "/", "%", "=", 
        "<", ">", "!", "not", "and", "or"
    ])
    分隔符列表: List[str] = field(default_factory=lambda: [
        ":", ";", ",", "(", ")", "{", "}", "[", "]"
    ])


class 增强词法分析器:
    """
    增强的词法分析器 - 使用ADT和模式匹配
    算法思路：
    1. 将源代码按字符流处理
    2. 使用有限状态机识别不同词法单元
    3. 使用模式匹配处理不同词法模式
    4. 维护错误栈和恢复树处理异常
    """
    
    def __init__(self, 源代码: str = "", 配置: 词法分析器配置 = None):
        self.源代码 = 源代码
        self.配置 = 配置 or 词法分析器配置()
        
        # 位置追踪
        self.当前位置 = 0
        self.行号 = 1
        self.列号 = 1
        
        # 异常处理
        self.异常处理中心 = 异常处理中心()
        
        # 预编译正则表达式
        self._编译正则表达式()
    
    def _编译正则表达式(self):
        """编译正则表达式以提高性能"""
        # 标识符模式：中文、英文、下划线开头，后续可包含数字
        self._标识符正则 = re.compile(r'^[\u4e00-\u9fa5a-zA-Z_][\u4e00-\u9fa5a-zA-Z0-9_]*')
        
        # 整数模式：可带负号
        self._整数正则 = re.compile(r'^-?\d+')
        
        # 浮点数模式
        self._浮点数正则 = re.compile(r'^-?\d+\.\d+')
        
        # 字符串模式：双引号或单引号包围
        self._字符串正则双引号 = re.compile(r'^"(?:[^"\\]|\\.)*"')
        self._字符串正则单引号 = re.compile(r"'(?:[^'\\]|\\.)*'")
        
        # 注释模式：单行注释
        self._单行注释正则 = re.compile(r'^//[^\n]*')
        
        # 空白字符模式
        self._空白正则 = re.compile(r'^\s+')
    
    def 设置源代码(self, 源代码: str):
        """设置源代码"""
        self.源代码 = 源代码
        self.当前位置 = 0
        self.行号 = 1
        self.列号 = 1
        self.异常处理中心.清除错误记录()
    
    def 分析(self) -> 可选[List[词法单元]]:
        """
        词法分析主函数
        返回：可选的词法单元列表，如果出错则为空
        
        伪代码：
        1. 初始化词法单元列表
        2. while 未到文件末尾:
            3. 跳过空白字符和注释
            4. 使用模式匹配尝试识别各种词法单元
            5. 如果识别成功，添加到列表并更新位置
            6. 如果识别失败，记录错误到异常栈并跳过当前字符
        7. 返回词法单元列表或错误
        """
        词法单元列表: List[词法单元] = []
        
        while self.当前位置 < len(self.源代码):
            # 1. 跳过空白字符
            空白匹配 = self._空白正则.match(self.源代码[self.当前位置:])
            if 空白匹配:
                空白文本 = 空白匹配.group(0)
                for 字符 in 空白文本:
                    if 字符 == '\n':
                        self.行号 += 1
                        self.列号 = 1
                    else:
                        self.列号 += 1
                self.当前位置 += len(空白文本)
                continue
            
            # 2. 跳过注释
            注释匹配 = self._单行注释正则.match(self.源代码[self.当前位置:])
            if 注释匹配:
                注释内容 = 注释匹配.group(0)
                if not self.配置.是否保留注释:
                    # 跳过注释
                    for 字符 in 注释内容:
                        if 字符 == '\n':
                            self.行号 += 1
                            self.列号 = 1
                        else:
                            self.列号 += 1
                    self.当前位置 += len(注释内容)
                    continue
                else:
                    # 保留注释作为词法单元
                    注释词法单元对象 = 注释词法单元(
                        内容=注释内容[2:],  # 去掉 //
                        行号=self.行号,
                        列号=self.列号,
                        位置=self.当前位置
                    )
                    词法单元列表.append(注释词法单元对象)
                    for 字符 in 注释内容:
                        if 字符 == '\n':
                            self.行号 += 1
                            self.列号 = 1
                        else:
                            self.列号 += 1
                    self.当前位置 += len(注释内容)
                    continue
            
            # 3. 尝试识别词法单元
            剩余文本 = self.源代码[self.当前位置:]
            
            # 3.1 识别字符串
            字符串匹配 = self._字符串正则双引号.match(剩余文本)
            if not 字符串匹配:
                字符串匹配 = self._字符串正则单引号.match(剩余文本)
            
            if 字符串匹配:
                字符串内容 = 字符串匹配.group(0)
                词法单元对象 = 字符串词法单元(
                    值=字符串内容[1:-1],  # 去掉引号
                    行号=self.行号,
                    列号=self.列号,
                    位置=self.当前位置
                )
                词法单元列表.append(词法单元对象)
                self.当前位置 += len(字符串内容)
                self.列号 += len(字符串内容)
                continue
            
            # 3.2 识别浮点数
            浮点匹配 = self._浮点数正则.match(剩余文本)
            if 浮点匹配:
                浮点文本 = 浮点匹配.group(0)
                词法单元对象 = 浮点数词法单元(
                    值=float(浮点文本),
                    行号=self.行号,
                    列号=self.列号,
                    位置=self.当前位置
                )
                词法单元列表.append(词法单元对象)
                self.当前位置 += len(浮点文本)
                self.列号 += len(浮点文本)
                continue
            
            # 3.3 识别整数
            整数匹配 = self._整数正则.match(剩余文本)
            if 整数匹配:
                整数文本 = 整数匹配.group(0)
                词法单元对象 = 数字词法单元(
                    值=int(整数文本),
                    行号=self.行号,
                    列号=self.列号,
                    位置=self.当前位置
                )
                词法单元列表.append(词法单元对象)
                self.当前位置 += len(整数文本)
                self.列号 += len(整数文本)
                continue
            
            # 3.4 识别标识符和关键字
            标识符匹配 = self._标识符正则.match(剩余文本)
            if 标识符匹配:
                标识符文本 = 标识符匹配.group(0)
                
                # 检查是否是关键字
                关键字列表 = self.配置.关键字列表
                标识符文本_lower = 标识符文本  # 默认使用原值
                if not self.配置.是否区分大小写:
                    标识符文本_lower = 标识符文本.lower()
                    关键字列表 = [k.lower() for k in self.配置.关键字列表]
                
                if 标识符文本 in 关键字列表 or 标识符文本_lower in 关键字列表:
                    # 关键字
                    实际关键字 = 标识符文本
                    if not self.配置.是否区分大小写:
                        for i, 关键字 in enumerate(self.配置.关键字列表):
                            if 关键字.lower() == 标识符文本_lower:
                                实际关键字 = 关键字
                                break
                    
                    词法单元对象 = 关键字词法单元(
                        值=实际关键字,
                        行号=self.行号,
                        列号=self.列号,
                        位置=self.当前位置
                    )
                else:
                    # 标识符
                    词法单元对象 = 标识符词法单元(
                        值=标识符文本,
                        行号=self.行号,
                        列号=self.列号,
                        位置=self.当前位置
                    )
                
                词法单元列表.append(词法单元对象)
                self.当前位置 += len(标识符文本)
                self.列号 += len(标识符文本)
                continue
            
            # 3.5 识别运算符（从长到短匹配）
            已匹配 = False
            for 运算符 in sorted(self.配置.运算符列表, key=len, reverse=True):
                if 剩余文本.startswith(运算符):
                    词法单元对象 = 运算符词法单元(
                        值=运算符,
                        行号=self.行号,
                        列号=self.列号,
                        位置=self.当前位置
                    )
                    词法单元列表.append(词法单元对象)
                    self.当前位置 += len(运算符)
                    self.列号 += len(运算符)
                    已匹配 = True
                    break
            
            if 已匹配:
                continue
            
            # 3.6 识别分隔符
            已匹配 = False
            for 分隔符 in self.配置.分隔符列表:
                if 剩余文本.startswith(分隔符):
                    词法单元对象 = 分隔符词法单元(
                        值=分隔符,
                        行号=self.行号,
                        列号=self.列号,
                        位置=self.当前位置
                    )
                    词法单元列表.append(词法单元对象)
                    self.当前位置 += len(分隔符)
                    self.列号 += len(分隔符)
                    已匹配 = True
                    break
            
            if 已匹配:
                continue
            
            # 3.7 无法识别的字符
            未知字符 = self.源代码[self.当前位置]
            self.异常处理中心.创建错误节点(
                错误信息=f"无法识别的字符: '{未知字符}'",
                行号=self.行号,
                列号=self.列号,
                错误类型=错误类型.词法错误,
                严重程度=错误级别.错误
            )
            self.当前位置 += 1
            self.列号 += 1
        
        # 4. 添加文件结束词法单元
        文件结束单元 = 文件结束词法单元(
            行号=self.行号,
            列号=self.列号,
            位置=self.当前位置
        )
        词法单元列表.append(文件结束单元)
        
        # 5. 返回结果
        if self.异常处理中心.有错误():
            return 可选()
        return 可选(词法单元列表)
    
    def 尝试识别词法单元(self) -> 可选[词法单元]:
        """
        尝试识别一个词法单元（备用方法，保留兼容）
        """
        # 这个方法已经整合到分析()方法中
        # 保留此方法是为了接口兼容
        结果 = self.分析()
        if 结果.不是空():
            列表 = 结果.获取值()
            if 列表:
                return 可选(列表[0])
        return 可选()
    
    def 处理词法错误(self, 错误信息: str):
        """处理词法分析错误 - 记录到异常栈并尝试恢复"""
        self.异常处理中心.创建错误节点(
            错误信息=错误信息,
            行号=self.行号,
            列号=self.列号,
            错误类型=错误类型.词法错误,
            严重程度=错误级别.错误
        )
    
    def 获取当前词法单元(self) -> 词法单元:
        """获取当前位置的词法单元（用于解析器）"""
        return None  # 由解析器管理词法单元列表
    
    def 获取错误列表(self) -> List[错误节点]:
        """获取所有错误"""
        return self.异常处理中心.获取所有错误()
    
    def 有错误(self) -> bool:
        """检查是否有错误"""
        return self.异常处理中心.有错误()


# ============ 便捷函数 ============

def 词法分析(源代码: str) -> 可选[List[词法单元]]:
    """
    便捷词法分析函数
    
    参数:
        源代码: 要分析的源代码字符串
    
    返回:
        可选的词法单元列表
    """
    分析器 = 增强词法分析器(源代码)
    return 分析器.分析()


# ============ 测试代码 ============

if __name__ == "__main__":
    print("测试词法分析器")
    print("=" * 60)
    
    测试代码 = """
循环 5 次:
    验证 "python -c 'print(测试)'"
    如果 验证通过:
        持久化
        调用AI "测试成功"
    否则:
        调用AI "测试失败"
    结束
"""
    
    print(f"测试代码:\n{测试代码}")
    print("=" * 60)
    
    分析器 = 增强词法分析器(测试代码)
    结果 = 分析器.分析()
    
    if 结果.不是空():
        词法单元列表 = 结果.获取值()
        print(f"词法分析成功，共 {len(词法单元列表)} 个词法单元:")
        print("-" * 60)
        
        for i, 单元 in enumerate(词法单元列表):
            单元类型 = type(单元).__name__
            if hasattr(单元, '值'):
                print(f"{i+1:3d}. {单元类型:20s} 行{单元.行号:3d} 列{单元.列号:3d} = {单元.值!r}")
            else:
                print(f"{i+1:3d}. {单元类型:20s} 行{单元.行号:3d} 列{单元.列号:3d}")
    else:
        print("词法分析失败:")
        for 错误 in 分析器.获取错误列表():
            print(f"  行{错误.行号}, 列{错误.列号}: {错误.错误信息}")
