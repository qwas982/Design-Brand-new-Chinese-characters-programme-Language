"""
代码生成器模块 - 将AST转换为栈机指令
本模块实现增强的代码生成器，使用访问者模式遍历AST
"""

from typing import List, Dict, Any, Optional
from dataclasses import dataclass, field

from 异常处理 import 异常处理中心, 错误节点, 错误类型, 错误级别
from 代数数据类型ADT import (
    程序节点, 循环节点, 验证节点, 持久化节点,
    AI调用节点, 条件节点, 块节点,
    字面量节点, 标识符节点, 二元表达式节点,
    一元表达式节点, 函数调用节点,
    变量声明节点, 赋值节点,
    指令, 访问者协议
)
from 拉尔夫原语 import 创建AI调用器, 创建验证器, 创建状态管理器


@dataclass
class 代码生成器配置:
    """代码生成器配置"""
    是否生成调试信息: bool = True
    优化级别: int = 1  # 0-无优化, 1-基本优化, 2-激进优化
    默认变量地址: int = 0


class 增强代码生成器(访问者协议):
    """
    增强的代码生成器 - 使用访问者模式遍历AST
    生成栈机指令序列
    
    算法思路：
    1. 使用访问者模式遍历AST
    2. 为每种AST节点类型生成对应的指令序列
    3. 维护符号表跟踪变量信息
    4. 使用栈计算表达式值
    """
    
    def __init__(self, 配置: 代码生成器配置 = None):
        self.配置 = 配置 or 代码生成器配置()
        
        # 输出
        self.指令序列: List[指令] = []
        
        # 符号表：变量名 -> (类型, 地址)
        self.符号表: Dict[str, Dict[str, Any]] = {}
        self.当前变量地址 = self.配置.默认变量地址
        
        # 临时变量
        self.临时变量计数 = 0
        
        # 标签管理
        self.标签计数 = 0
        self.循环信息栈 = []  # 跟踪循环信息
        self.作用域栈: List[Dict[str, bool]] = []  # 作用域栈
        
        # 异常处理
        self.异常处理中心 = 异常处理中心()
        
        # 调试支持
        if self.配置.是否生成调试信息:
            self.调试信息字典: Dict[int, Dict] = {}
    
    def 重置(self):
        """重置代码生成器状态"""
        self.指令序列.clear()
        self.符号表.clear()
        self.临时变量计数 = 0
        self.标签计数 = 0
        self.循环信息栈.clear()
        self.作用域栈.clear()
        self.当前变量地址 = self.配置.默认变量地址
    
    def 生成代码(self, AST根节点: 程序节点) -> List[指令]:
        """
        代码生成入口点
        
        参数:
            AST根节点: 语法分析产生的AST根节点
        
        返回:
            栈机指令序列
        """
        self.重置()
        
        # 生成程序头信息
        if self.配置.是否生成调试信息:
            self.指令序列.append(指令("标签", "程序开始"))
        
        # 生成全局代码
        self.访问程序节点(AST根节点)
        
        # 生成程序结束指令
        self.指令序列.append(指令("停机"))
        
        # 应用优化
        if self.配置.优化级别 > 0:
            self.应用优化()
        
        return self.指令序列
    
    def 应用优化(self):
        """应用代码优化"""
        if self.配置.优化级别 >= 1:
            self.优化常量折叠()
        
        if self.配置.优化级别 >= 2:
            self.优化死代码消除()
            self.优化公共子表达式消除()
    
    def 优化常量折叠(self):
        """常量折叠优化"""
        优化后序列 = []
        索引 = 0
        
        while 索引 < len(self.指令序列):
            指令 = self.指令序列[索引]
            
            # 查找连续的推入和二元运算
            if (指令.操作码 == "推入" and 
                索引 + 2 < len(self.指令序列) and
                self.指令序列[索引 + 1].操作码 in ["加法", "减法", "乘法", "除法"]):
                
                左值 = 指令.操作数
                右指令 = self.指令序列[索引 + 2]
                
                if 右指令.操作码 == "推入":
                    右值 = 右指令.操作数
                    运算指令 = self.指令序列[索引 + 1]
                    
                    # 计算结果
                    if 运算指令.操作码 == "加法":
                        结果 = 左值 + 右值
                    elif 运算指令.操作码 == "减法":
                        结果 = 左值 - 右值
                    elif 运算指令.操作码 == "乘法":
                        结果 = 左值 * 右值
                    elif 运算指令.操作码 == "除法" and 右值 != 0:
                        结果 = 左值 / 右值
                    else:
                        优化后序列.append(指令)
                        索引 += 1
                        continue
                    
                    优化后序列.append(指令("推入", 结果))
                    索引 += 3
                    continue
            
            优化后序列.append(指令)
            索引 += 1
        
        self.指令序列 = 优化后序列
    
    def 优化死代码消除(self):
        """死代码消除"""
        # 简化实现：移除无法到达的停机指令
        可达 = set()
        索引 = 0
        
        while 索引 < len(self.指令序列):
            if 索引 not in 可达:
                可达.add(索引)
            
            指令 = self.指令序列[索引]
            
            if 指令.操作码 == "跳转":
                目标 = self._查找标签地址(指令.操作数)
                if 目标 is not None:
                    可达.add(目标)
            elif 指令.操作码 == "条件跳转":
                目标 = self._查找标签地址(指令.操作数)
                if 目标 is not None:
                    可达.add(目标)
                    可达.add(索引 + 1)
            
            索引 += 1
        
        # 移除不可达指令（简化：只保留可达的）
        self.指令序列 = [指令 for i, 指令 in enumerate(self.指令序列) if i in 可达]
    
    def 优化公共子表达式消除(self):
        """公共子表达式消除 - 简化版"""
        # 在实际编译器中会更复杂
        pass
    
    # ============ 访问者方法实现 ============
    
    def 访问程序节点(self, 节点: 程序节点):
        """访问程序节点"""
        # 进入新作用域
        self.作用域栈.append({})
        
        for 语句 in 节点.语句列表:
            语句.接受访问者(self)
        
        # 退出作用域
        self.作用域栈.pop()
    
    def 访问循环节点(self, 节点: 循环节点):
        """生成循环代码"""
        循环开始标签 = self._生成唯一标签("循环开始")
        循环结束标签 = self._生成唯一标签("循环结束")
        
        # 保存循环信息
        self.循环信息栈.append({
            "开始标签": 循环开始标签,
            "结束标签": 循环结束标签
        })
        
        # 生成循环开始标签
        self.指令序列.append(指令("标签", 循环开始标签))
        
        # 生成循环条件（使用计数器）
        节点.循环次数.接受访问者(self)
        self.指令序列.append(指令("推入", 1))  # 计数器初始值
        self.指令序列.append(指令("大于"))  # 计数器 > 0
        self.指令序列.append(指令("条件跳转", 循环结束标签))
        
        # 生成循环体
        节点.循环体.接受访问者(self)
        
        # 循环递减
        self.指令序列.append(指令("推入", 1))
        self.指令序列.append(指令("减法"))
        
        # 跳回循环开始
        self.指令序列.append(指令("跳转", 循环开始标签))
        
        # 生成循环结束标签
        self.指令序列.append(指令("标签", 循环结束标签))
        
        # 弹出循环信息
        self.循环信息栈.pop()
    
    def 访问验证节点(self, 节点: 验证节点):
        """生成验证指令"""
        # 生成验证命令表达式
        节点.验证命令.接受访问者(self)
        
        # 生成验证调用指令
        self.指令序列.append(指令("调用外部", "验证器"))
    
    def 访问持久化节点(self, 节点: 持久化节点):
        """生成持久化指令"""
        # 生成路径表达式
        if 节点.路径表达式:
            节点.路径表达式.接受访问者(self)
        else:
            self.指令序列.append(指令("推入", "./状态存储"))
        
        # 推入状态数据（简化：使用当前操作数栈顶）
        self.指令序列.append(指令("复制栈顶"))
        
        # 生成持久化调用指令
        self.指令序列.append(指令("调用外部", "持久化器"))
    
    def 访问AI调用节点(self, 节点: AI调用节点):
        """生成AI调用指令"""
        # 生成任务描述表达式
        节点.任务描述.接受访问者(self)
        
        # 生成AI调用指令
        self.指令序列.append(指令("调用外部", "AI调用器"))
    
    def 访问条件节点(self, 节点: 条件节点):
        """生成条件分支代码"""
        条件真标签 = self._生成唯一标签("条件真")
        条件假标签 = self._生成唯一标签("条件假")
        条件结束标签 = self._生成唯一标签("条件结束")
        
        # 生成条件表达式
        节点.条件表达式.接受访问者(self)
        
        # 条件跳转（假分支）
        self.指令序列.append(指令("条件跳转", 条件假标签))
        
        # 真分支
        self.指令序列.append(指令("标签", 条件真标签))
        节点.真分支.接受访问者(self)
        self.指令序列.append(指令("跳转", 条件结束标签))
        
        # 假分支
        if 节点.假分支:
            self.指令序列.append(指令("标签", 条件假标签))
            节点.假分支.接受访问者(self)
        
        # 条件结束
        self.指令序列.append(指令("标签", 条件结束标签))
    
    def 访问块节点(self, 节点: 块节点):
        """访问块节点"""
        # 进入新作用域
        self.作用域栈.append({})
        
        for 语句 in 节点.语句列表:
            语句.接受访问者(self)
        
        # 退出作用域
        self.作用域栈.pop()
    
    def 访问字面量节点(self, 节点: 字面量节点):
        """生成字面量代码"""
        self.指令序列.append(指令("推入", 节点.值))
    
    def 访问标识符节点(self, 节点: 标识符节点):
        """生成标识符代码"""
        if 节点.名称 in self.符号表:
            地址 = self.符号表[节点.名称]["地址"]
            self.指令序列.append(指令("加载", 地址))
        else:
            # 未定义变量，使用默认值
            self.指令序列.append(指令("推入", 0))
    
    def 访问二元表达式节点(self, 节点: 二元表达式节点):
        """生成二元表达式代码"""
        # 生成左操作数
        节点.左表达式.接受访问者(self)
        
        # 生成右操作数
        节点.右表达式.接受访问者(self)
        
        # 生成运算符指令
        self._生成运算符指令(节点.运算符)
    
    def 访问一元表达式节点(self, 节点: 一元表达式节点):
        """生成一元表达式代码"""
        节点.表达式.接受访问者(self)
        
        if 节点.运算符 == "-":
            self.指令序列.append(指令("推入", -1))
            self.指令序列.append(指令("乘法"))
        elif 节点.运算符 in ["!", "not"]:
            self.指令序列.append(指令("推入", 0))
            self.指令序列.append(指令("等于"))
    
    def 访问函数调用节点(self, 节点: 函数调用节点):
        """生成函数调用代码"""
        # 生成参数
        for 参数 in reversed(节点.参数列表):
            参数.接受访问者(self)
        
        # 模拟函数调用（简化版）
        self.指令序列.append(指令("推入", 节点.函数名))
        self.指令序列.append(指令("调用外部", "AI调用器"))
    
    def 访问变量声明节点(self, 节点: 变量声明节点):
        """生成变量声明代码"""
        # 分配变量地址
        地址 = self.当前变量地址
        self.当前变量地址 += 4  # 每个变量占用4字节
        
        # 注册到符号表
        self.符号表[节点.变量名] = {
            "类型": 节点.类型 or "整数",
            "地址": 地址,
            "声明行": 节点.获取行号()
        }
        
        # 如果有初始值，生成赋值代码
        if 节点.初始值:
            节点.初始值.接受访问者(self)
            self.指令序列.append(指令("存储", 地址))
    
    def 访问赋值节点(self, 节点: 赋值节点):
        """生成赋值代码"""
        # 生成值表达式
        节点.值表达式.接受访问者(self)
        
        # 存储到变量地址
        if 节点.变量名 in self.符号表:
            地址 = self.符号表[节点.变量名]["地址"]
            self.指令序列.append(指令("存储", 地址))
    
    # ============ 辅助方法 ============
    
    def _生成唯一标签(self, 前缀: str) -> str:
        """生成唯一标签名"""
        标签名 = f"{前缀}_{self.标签计数}"
        self.标签计数 += 1
        return 标签名
    
    def _生成运算符指令(self, 运算符: str):
        """生成运算符对应的指令"""
        运算符映射 = {
            "+": "加法",
            "-": "减法",
            "*": "乘法",
            "/": "除法",
            "%": "取模",
            "==": "等于",
            "!=": "不等于",
            ">": "大于",
            "<": "小于",
            ">=": "大于等于",
            "<=": "小于等于",
            "&&": None,  # 暂不支持
            "||": None,  # 暂不支持
        }
        
        指令名 = 运算符映射.get(运算符)
        if 指令名:
            self.指令序列.append(指令(指令名))
        else:
            # 抛出异常或使用默认处理
            self.异常处理中心.创建错误节点(
                错误信息=f"不支持的运算符: {运算符}",
                行号=0, 列号=0,
                错误类型=错误类型.语义错误
            )
    
    def _查找标签地址(self, 标签名: str) -> Optional[int]:
        """查找标签对应的指令地址"""
        for 地址, 指令 in enumerate(self.指令序列):
            if 指令.操作码 == "标签" and 指令.操作数 == 标签名:
                return 地址
        return None
    
    def 获取符号表(self) -> Dict[str, Dict]:
        """获取符号表"""
        return self.符号表.copy()
    
    def 获取指令序列(self) -> List[指令]:
        """获取指令序列"""
        return self.指令序列.copy()
    
    def 输出代码(self):
        """输出生成的代码"""
        print("生成的栈机指令:")
        print("=" * 40)
        
        for i, 指令 in enumerate(self.指令序列):
            if 指令.操作码 == "标签":
                print(f"{'':4s} {指令.操作数}:")
            else:
                if 指令.操作数 is not None:
                    print(f"{i:4d}: {指令.操作码:10s} {指令.操作数}")
                else:
                    print(f"{i:4d}: {指令.操作码}")
        
        print("=" * 40)
        print(f"共 {len(self.指令序列)} 条指令")
        print(f"变量数量: {len(self.符号表)}")
        print(f"临时变量数量: {self.临时变量计数}")


# ============ 便捷函数 ============

def 生成代码(AST根节点: 程序节点, 优化级别: int = 1) -> List[指令]:
    """
    便捷代码生成函数
    
    参数:
        AST根节点: 语法分析产生的AST根节点
        优化级别: 0-无优化, 1-基本优化, 2-激进优化
    
    返回:
        栈机指令序列
    """
    配置 = 代码生成器配置(优化级别=优化级别)
    生成器 = 增强代码生成器(配置)
    return 生成器.生成代码(AST根节点)


# ============ 测试代码 ============

if __name__ == "__main__":
    print("测试代码生成器")
    print("=" * 60)
    
    # 创建测试AST
    from 代数数据类型ADT import (
        程序节点, 循环节点, 块节点,
        验证节点, 条件节点,
        字面量节点, 标识符节点
    )
    
    # 构建测试程序
    测试程序 = 程序节点(
        语句列表=[
            循环节点(
                循环次数=字面量节点(值=5, 类型="整数"),
                循环体=块节点(
                    语句列表=[
                        验证节点(
                            验证命令=字面量节点(值="python test.py", 类型="字符串")
                        ),
                        条件节点(
                            条件表达式=标识符节点(名称="验证通过"),
                            真分支=块节点(语句列表=[]),
                            假分支=块节点(语句列表=[])
                        )
                    ]
                )
            )
        ]
    )
    
    # 生成代码
    生成器 = 增强代码生成器()
    指令序列 = 生成器.生成代码(测试程序)
    
    # 输出结果
    生成器.输出代码()
