"""
编译管道模块 - 整合所有编译阶段
本模块实现统一的编译器架构，整合词法分析、语法分析、代码生成等阶段

流水线：源代码 -> 词法分析 -> 语法分析 -> 语义分析 -> 代码生成 -> 优化
"""

from typing import List, Optional, Dict, Any
from dataclasses import dataclass, field
from enum import Enum

from 异常处理 import (
    异常处理中心, 错误节点, 错误类型, 错误级别
)
from 代数数据类型ADT import (
    可选, 程序节点, 指令
)
from 词法器 import 增强词法分析器
from 解析器 import 增强递归下降解析器
from 代码生成器 import 增强代码生成器, 代码生成器配置


@dataclass
class 编译管道配置:
    """编译管道配置"""
    是否启用优化: bool = True
    优化级别: int = 1
    是否保留调试信息: bool = True
    词法分析配置: dict = field(default_factory=dict)
    解析器配置: dict = field(default_factory=dict)
    代码生成配置: dict = field(default_factory=dict)


class 编译管道异常(Exception):
    """编译管道异常"""
    pass


class 编译管道阶段(Enum):
    """编译管道阶段枚举"""
    词法分析 = "词法分析"
    语法分析 = "语法分析"
    代码生成 = "代码生成"
    代码优化 = "代码优化"
    未知 = "未知"


class 拉尔夫编译管道:
    """
    统一的编译器架构 - 整合所有组件
    流水线：源代码 -> 词法分析 -> 语法分析 -> 代码生成 -> 优化
    """
    
    def __init__(self, 配置: 编译管道配置 = None):
        self.配置 = 配置 or 编译管道配置()
        
        # 编译阶段组件
        self.词法分析器 = 增强词法分析器()
        self.语法分析器 = 增强递归下降解析器()
        self.代码生成器 = 增强代码生成器(
            代码生成器配置(
                是否生成调试信息=self.配置.是否保留调试信息,
                优化级别=self.配置.优化级别
            )
        )
        
        # 中间结果
        self.词法单元列表: Optional[List] = None
        self.抽象语法树: Optional[程序节点] = None
        self.中间代码: List[指令] = []
        self.优化后代码: List[指令] = []
        
        # 错误和警告收集
        self.异常处理中心 = 异常处理中心()
        
        # 编译统计
        self.编译统计: Dict[str, Any] = {}
    
    def 编译(self, 源代码: str) -> 可选[List[指令]]:
        """
        完整编译流程
        
        伪代码：
        1. 重置所有状态
        2. 词法分析 -> 词法单元列表
        3. 语法分析 -> 抽象语法树
        4. 代码生成 -> 中间代码
        5. 代码优化 -> 优化代码
        6. 错误处理：如果有错误则返回错误，否则返回代码
        
        参数:
            源代码: 要编译的源代码字符串
        
        返回:
            可选的指令序列
        """
        import time
        开始时间 = time.time()
        
        # 重置状态
        self._重置状态()
        
        print("=" * 60)
        print("开始编译")
        print("=" * 60)
        
        try:
            # 阶段1: 词法分析
            self._阶段词法分析(源代码)
            
            # 阶段2: 语法分析
            self._阶段语法分析()
            
            # 阶段3: 代码生成
            self._阶段代码生成()
            
            # 阶段4: 代码优化
            if self.配置.是否启用优化:
                self._阶段代码优化()
            else:
                # 如果没有启用优化，优化后代码等同于中间代码
                self.优化后代码 = self.中间代码
            
            # 计算编译统计
            编译耗时 = time.time() - 开始时间
            self.编译统计 = {
                "编译耗时": f"{编译耗时:.4f}秒",
                "词法单元数量": len(self.词法单元列表) if self.词法单元列表 else 0,
                "AST节点数": self._计算AST节点数(self.抽象语法树) if self.抽象语法树 else 0,
                "原始指令数": len(self.中间代码),
                "优化后指令数": len(self.优化后代码),
                "优化减少数": len(self.中间代码) - len(self.优化后代码),
                "错误数": self.异常处理中心.获取错误数量(),
                "警告数": 0
            }
            
            print("\n" + "=" * 60)
            print(f"编译成功!")
            print(f"  词法单元: {self.编译统计['词法单元数量']}")
            print(f"  AST节点: {self.编译统计['AST节点数']}")
            print(f"  生成指令: {self.编译统计['优化后指令数']}")
            print(f"  编译耗时: {self.编译统计['编译耗时']}")
            print("=" * 60)
            
            return 可选(self.优化后代码)
            
        except Exception as 编译异常:
            self.异常处理中心.创建错误节点(
                错误信息=f"编译过程异常: {编译异常}",
                行号=0, 列号=0,
                错误类型=错误类型.运行时错误
            )
            return 可选()
    
    def _重置状态(self):
        """重置编译状态"""
        self.词法单元列表 = None
        self.抽象语法树 = None
        self.中间代码 = []
        self.优化后代码 = []
        self.异常处理中心.清除错误记录()
        self.编译统计 = {}
    
    def _阶段词法分析(self, 源代码: str):
        """阶段1: 词法分析"""
        print("\n阶段1: 词法分析")
        print("-" * 40)
        
        # 设置源代码
        self.词法分析器.设置源代码(源代码)
        
        # 执行词法分析
        词法结果 = self.词法分析器.分析()
        
        if 词法结果.是空():
            # 词法分析失败
            for 错误 in self.词法分析器.获取错误列表():
                self.异常处理中心.记录错误(错误)
            
            错误数 = len(self.词法分析器.获取错误列表())
            print(f"❌ 词法分析失败: {错误数} 个错误")
            raise 编译管道异常("词法分析失败")
        
        # 提取词法单元列表
        self.词法单元列表 = 词法结果.获取值()
        print(f"✓ 词法分析成功: {len(self.词法单元列表)} 个词法单元")
    
    def _阶段语法分析(self):
        """阶段2: 语法分析"""
        print("\n阶段2: 语法分析")
        print("-" * 40)
        
        if not self.词法单元列表:
            print("❌ 缺少词法分析结果")
            raise 编译管道异常("缺少词法分析结果")
        
        # 设置词法单元列表
        self.语法分析器.设置词法单元列表(self.词法单元列表)
        
        # 执行语法分析
        语法结果 = self.语法分析器.解析()
        
        if 语法结果.是空():
            # 语法分析失败
            for 错误 in self.语法分析器.获取错误列表():
                self.异常处理中心.记录错误(错误)
            
            错误数 = len(self.语法分析器.获取错误列表())
            print(f"❌ 语法分析失败: {错误数} 个错误")
            raise 编译管道异常("语法分析失败")
        
        # 提取抽象语法树
        self.抽象语法树 = 语法结果.获取值()
        AST节点数 = self._计算AST节点数(self.抽象语法树)
        print(f"✓ 语法分析成功: {AST节点数} 个AST节点")
    
    def _阶段代码生成(self):
        """阶段3: 代码生成"""
        print("\n阶段3: 代码生成")
        print("-" * 40)
        
        if not self.抽象语法树:
            print("❌ 缺少语法分析结果")
            raise 编译管道异常("缺少语法分析结果")
        
        # 生成代码
        self.中间代码 = self.代码生成器.生成代码(self.抽象语法树)
        print(f"✓ 代码生成成功: {len(self.中间代码)} 条指令")
    
    def _阶段代码优化(self):
        """阶段4: 代码优化"""
        print("\n阶段4: 代码优化")
        print("-" * 40)
        
        if not self.中间代码:
            self.优化后代码 = self.中间代码
            print("✓ 无需优化")
            return
        
        # 优化级别1: 常量折叠、死代码消除
        原始指令数 = len(self.中间代码)
        
        # 手动应用优化
        self.优化后代码 = self._应用基本优化(self.中间代码)
        
        优化减少数 = 原始指令数 - len(self.优化后代码)
        print(f"✓ 代码优化完成: 减少 {优化减少数} 条指令")
    
    def _应用基本优化(self, 指令序列: List[指令]) -> List[指令]:
        """应用基本优化"""
        优化后序列 = []
        索引 = 0
        
        while 索引 < len(指令序列):
            指令 = 指令序列[索引]
            
            # 1. 常量折叠
            if (指令.操作码 == "推入" and 
                索引 + 2 < len(指令序列) and
                指令序列[索引 + 1].操作码 in ["加法", "减法", "乘法", "除法"]):
                
                左值 = 指令.操作数
                右指令 = 指令序列[索引 + 2]
                
                if 右指令.操作码 == "推入":
                    右值 = 右指令.操作数
                    运算指令 = 指令序列[索引 + 1]
                    
                    # 计算结果
                    if 运算指令.操作码 == "加法":
                        结果 = 左值 + 右值
                    elif 运算指令.操作码 == "减法":
                        结果 = 左值 - 右值
                    elif 运算指令.操作码 == "乘法":
                        结果 = 左值 * 右值
                    elif 运算指令.操作码 == "除法" and 右值 != 0:
                        结果 = 左值 / 右值
                    else:
                        优化后序列.append(指令)
                        索引 += 1
                        continue
                    
                    优化后序列.append(指令("推入", 结果))
                    索引 += 3
                    continue
            
            # 2. 移除无法到达的停机指令（简化）
            if 指令.操作码 == "停机" and 索引 < len(指令序列) - 1:
                # 检查是否有跳转指令指向后面的指令
                可达 = False
                for j in range(索引):
                    prev = 指令序列[j]
                    if prev.操作码 in ["跳转", "条件跳转"]:
                        目标 = prev.操作数
                        # 简化检查
                        可达 = True
                
                if not 可达:
                    索引 += 1
                    continue
            
            优化后序列.append(指令)
            索引 += 1
        
        return 优化后序列
    
    def _计算AST节点数(self, 节点) -> int:
        """递归计算AST节点数量"""
        if 节点 is None:
            return 0
        
        计数 = 1
        
        # 程序节点
        if hasattr(节点, '语句列表'):
            for 语句 in 节点.语句列表:
                计数 += self._计算AST节点数(语句)
        
        # 循环节点
        if hasattr(节点, '循环体'):
            计数 += self._计算AST节点数(节点.循环体)
            if hasattr(节点, '循环次数'):
                计数 += self._计算AST节点数(节点.循环次数)
        
        # 条件节点
        if hasattr(节点, '真分支'):
            计数 += self._计算AST节点数(节点.真分支)
        if hasattr(节点, '假分支') and 节点.假分支:
            计数 += self._计算AST节点数(节点.假分支)
        if hasattr(节点, '条件表达式'):
            计数 += self._计算AST节点数(节点.条件表达式)
        
        # 二元表达式
        if hasattr(节点, '左表达式'):
            计数 += self._计算AST节点数(节点.左表达式)
        if hasattr(节点, '右表达式'):
            计数 += self._计算AST节点数(节点.右表达式)
        
        return 计数
    
    def 生成编译报告(self) -> Dict[str, Any]:
        """生成详细的编译报告"""
        return {
            "编译状态": "成功" if not self.异常处理中心.有错误() else "失败",
            "错误数量": self.异常处理中心.获取错误数量(),
            "警告数量": 0,
            "词法单元数量": len(self.词法单元列表) if self.词法单元列表 else 0,
            "AST节点数": self._计算AST节点数(self.抽象语法树) if self.抽象语法树 else 0,
            "原始指令数": len(self.中间代码),
            "优化后指令数": len(self.优化后代码),
            "优化比例": f"{(1 - len(self.优化后代码)/len(self.中间代码))*100:.1f}%" if self.中间代码 else "0%",
            "错误列表": [错误.转字典() for 错误 in self.异常处理中心.获取所有错误()],
            "编译统计": self.编译统计
        }
    
    def 获取错误列表(self) -> List[错误节点]:
        """获取所有错误"""
        return self.异常处理中心.获取所有错误()
    
    def 有错误(self) -> bool:
        """检查是否有错误"""
        return self.异常处理中心.有错误()
    
    def 获取中间结果(self) -> Dict[str, Any]:
        """获取编译中间结果"""
        return {
            "词法单元列表": self.词法单元列表,
            "抽象语法树": self.抽象语法树,
            "中间代码": self.中间代码,
            "优化后代码": self.优化后代码
        }


# ============ 便捷函数 ============

def 编译(源代码: str, 优化级别: int = 1) -> 可选[List[指令]]:
    """
    便捷编译函数
    
    参数:
        源代码: 要编译的源代码字符串
        优化级别: 0-无优化, 1-基本优化
    
    返回:
        可选的指令序列
    """
    配置 = 编译管道配置(
        是否启用优化=优化级别 > 0,
        优化级别=优化级别
    )
    管道 = 拉尔夫编译管道(配置)
    return 管道.编译(源代码)


# ============ 测试代码 ============

if __name__ == "__main__":
    print("测试编译管道")
    print("=" * 60)
    
    测试代码 = """
循环 3:
    验证 "python test.py"
    如果 验证通过:
        持久化 "./结果.json"
    否则:
        调用AI "测试失败，请分析"
    结束
结束
"""
    
    print(f"测试代码:\n{测试代码}")
    print("=" * 60)
    
    # 编译
    管道 = 拉尔夫编译管道()
    结果 = 管道.编译(测试代码)
    
    if 结果.不是空():
        指令序列 = 结果.获取值()
        print(f"\n编译成功，生成 {len(指令序列)} 条指令")
        
        # 输出指令
        print("\n生成的指令:")
        for i, 指令 in enumerate(指令序列):
            if 指令.操作码 == "标签":
                print(f"  {指令.操作数}:")
            else:
                操作数 = f" {指令.操作数}" if 指令.操作数 is not None else ""
                print(f"  {i:3d}: {指令.操作码}{操作数}")
    else:
        print("\n编译失败:")
        for 错误 in 管道.获取错误列表():
            print(f"  行{错误.行号}, 列{错误.列号}: {错误.错误信息}")
