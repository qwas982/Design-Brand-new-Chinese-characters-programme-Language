"""
拉尔夫编译器完整测试套件
测试所有模块的功能和集成
"""

import sys
import os

# 确保可以导入模块
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))


class 测试结果收集器:
    """测试结果收集器"""
    
    def __init__(self):
        self.通过数 = 0
        self.失败数 = 0
        self.跳过数 = 0
        self.结果列表 = []
    
    def 添加通过(self, 测试名: str, 详细信息: str = ""):
        self.通过数 += 1
        self.结果列表.append(("✓", 测试名, 详细信息))
        print(f"  ✓ {测试名}")
    
    def 添加失败(self, 测试名: str, 错误信息: str):
        self.失败数 += 1
        self.结果列表.append(("✗", 测试名, 错误信息))
        print(f"  ✗ {测试名}: {错误信息}")
    
    def 添加跳过(self, 测试名: str, 原因: str):
        self.跳过数 += 1
        self.结果列表.append(("⊘", 测试名, 原因))
        print(f"  ⊘ {测试名} (跳过: {原因})")
    
    def 输出报告(self):
        print("\n" + "=" * 60)
        print("测试结果汇总")
        print("=" * 60)
        print(f"通过: {self.通过数}")
        print(f"失败: {self.失败数}")
        print(f"跳过: {self.跳过数}")
        print(f"总计: {self.通过数 + self.失败数 + self.跳过数}")
        print("=" * 60)
        
        if self.失败数 > 0:
            print("\n失败的测试:")
            for 状态, 名称, 详情 in self.结果列表:
                if 状态 == "✗":
                    print(f"  - {名称}: {详情}")
        
        return self.失败数 == 0


def 测试异常处理模块(收集器: 测试结果收集器):
    """测试异常处理模块"""
    print("\n" + "=" * 60)
    print("测试 异常处理模块")
    print("=" * 60)
    
    try:
        from 异常处理 import (
            错误节点, 错误类型, 错误级别,
            异常处理中心, 安全执行器,
            编译异常基类, 词法分析异常, 语法分析异常
        )
        
        # 测试1: 错误节点创建
        try:
            节点 = 错误节点(
                错误信息="测试错误",
                行号=10,
                列号=5,
                错误类型=错误类型.词法错误,
                严重程度=错误级别.错误
            )
            收集器.添加通过("错误节点创建")
            
            # 测试转字典
            字典 = 节点.转字典()
            assert "错误信息" in 字典
            收集器.添加通过("错误节点转字典")
        except Exception as e:
            收集器.添加失败("错误节点创建", str(e))
        
        # 测试2: 异常处理中心
        try:
            中心 = 异常处理中心()
            assert 中心.获取错误数量() == 0
            收集器.添加通过("异常处理中心创建")
            
            中心.创建错误节点("错误1", 1, 1, 错误类型.词法错误)
            中心.创建错误节点("错误2", 2, 2, 错误类型.语法错误)
            assert 中心.获取错误数量() == 2
            收集器.添加通过("异常处理中心错误记录")
            
            中心.清除错误记录()
            assert 中心.获取错误数量() == 0
            收集器.添加通过("异常处理中心清除记录")
        except Exception as e:
            收集器.添加失败("异常处理中心测试", str(e))
        
        # 测试3: 恢复策略
        try:
            中心 = 异常处理中心()
            策略 = 中心.获取恢复策略("词法错误")
            assert 策略 == "跳过字符"
            收集器.添加通过("获取恢复策略")
        except Exception as e:
            收集器.添加失败("恢复策略测试", str(e))
        
        # 测试4: 安全执行器
        try:
            中心 = 异常处理中心()
            执行器 = 安全执行器(中心)
            
            成功计数器 = [0]
            
            def 成功函数():
                成功计数器[0] += 1
                return "成功"
            
            结果 = 执行器.安全执行(成功函数, "测试操作")
            assert 结果 == "成功"
            assert 成功计数器[0] == 1
            收集器.添加通过("安全执行器-成功执行")
            
            # 测试重试
            失败计数器 = [0]
            def 失败函数():
                失败计数器[0] += 1
                if 失败计数器[0] < 3:
                    raise ValueError("临时失败")
                return "重试成功"
            
            结果 = 执行器.安全执行(失败函数, "测试重试")
            assert 结果 == "重试成功"
            收集器.添加通过("安全执行器-重试机制")
        except Exception as e:
            收集器.添加失败("安全执行器测试", str(e))
        
        # 测试5: 异常类继承
        try:
            exc = 语法分析异常("语法错误", 行号=5, 列号=10)
            assert "语法错误" in str(exc)
            assert "行5" in str(exc)
            收集器.添加通过("异常类继承")
        except Exception as e:
            收集器.添加失败("异常类继承测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("异常处理模块", f"导入失败: {e}")


def 测试代数数据类型模块(收集器: 测试结果收集器):
    """测试代数数据类型模块"""
    print("\n" + "=" * 60)
    print("测试 代数数据类型ADT模块")
    print("=" * 60)
    
    try:
        from 代数数据类型ADT import (
            可选, 要么, 匹配器, 模式匹配函数,
            关键字词法单元, 标识符词法单元, 数字词法单元,
            程序节点, 循环节点, 条件节点, 块节点,
            字面量节点, 标识符节点, 二元表达式节点
        )
        
        # 测试1: 可选类型
        try:
            可选值 = 可选(42)
            assert 可选值.不是空()
            assert 可选值.获取值() == 42
            收集器.添加通过("可选类型-创建和获取")
            
            空可选 = 可选()
            assert 空可选.是空()
            收集器.添加通过("可选类型-空值检查")
            
            # 测试映射
            结果 = 可选值.映射(lambda x: x * 2)
            assert 结果.获取值() == 84
            收集器.添加通过("可选类型-映射")
            
            # 测试绑定
            def 返回可选(x):
                return 可选(x + 1)
            
            结果 = 可选值.绑定(返回可选)
            assert 结果.获取值() == 43
            收集器.添加通过("可选类型-绑定")
        except Exception as e:
            收集器.添加失败("可选类型测试", str(e))
        
        # 测试2: Either类型
        try:
            左值 = 要么("左值", None)
            右值 = 要么(None, "右值")
            
            assert 左值.是左值()
            assert not 左值.是右值()
            assert 右值.是右值()
            收集器.添加通过("Either类型-左右值判断")
            
            assert 左值.模式匹配(lambda x: f"左:{x}", lambda x: f"右:{x}") == "左:左值"
            收集器.添加通过("Either类型-模式匹配")
        except Exception as e:
            收集器.添加失败("Either类型测试", str(e))
        
        # 测试3: 匹配器
        try:
            m = 匹配器(42)
            assert m.匹配(42)
            收集器.添加通过("匹配器-值匹配")
            
            m = 匹配器("test")
            assert m.匹配(str)
            收集器.添加通过("匹配器-类型匹配")
            
            m = 匹配器(100)
            assert m.匹配((1, 100, 3))  # 元组不匹配
            收集器.添加通过("匹配器-元组匹配")
        except Exception as e:
            收集器.添加失败("匹配器测试", str(e))
        
        # 测试4: 词法单元ADT
        try:
            关键字 = 关键字词法单元(值="循环", 行号=1, 列号=1, 位置=0)
            assert 关键字.值 == "循环"
            收集器.添加通过("关键字词法单元")
            
            标识符 = 标识符词法单元(值="变量名", 行号=1, 列号=5, 位置=10)
            assert 标识符.值 == "变量名"
            收集器.添加通过("标识符词法单元")
            
            数字 = 数字词法单元(值=123, 行号=1, 列号=10, 位置=20)
            assert 数字.值 == 123
            收集器.添加通过("数字词法单元")
        except Exception as e:
            收集器.添加失败("词法单元ADT测试", str(e))
        
        # 测试5: AST节点
        try:
            字面量 = 字面量节点(值=10, 类型="整数")
            字面量2 = 字面量节点(值=20, 类型="整数")
            
            二元 = 二元表达式节点(
                左表达式=字面量,
                运算符="+",
                右表达式=字面量2
            )
            assert 二元.运算符 == "+"
            收集器.添加通过("二元表达式节点")
            
            # 测试遍历
            遍历结果 = []
            def 回调(节点):
                遍历结果.append(type(节点).__name__)
            
            二元.遍历(回调)
            assert "二元表达式节点" in 遍历结果
            assert "字面量节点" in 遍历结果
            收集器.添加通过("AST节点遍历")
        except Exception as e:
            收集器.添加失败("AST节点测试", str(e))
        
        # 测试6: 程序节点
        try:
            程序 = 程序节点(语句列表=[
                字面量节点(值=1, 类型="整数"),
                字面量节点(值=2, 类型="整数")
            ])
            assert len(程序.语句列表) == 2
            收集器.添加通过("程序节点创建")
        except Exception as e:
            收集器.添加失败("程序节点测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("代数数据类型模块", f"导入失败: {e}")


def 测试拉尔夫原语模块(收集器: 测试结果收集器):
    """测试拉尔夫原语模块"""
    print("\n" + "=" * 60)
    print("测试 拉尔夫原语模块")
    print("=" * 60)
    
    try:
        from 拉尔夫原语 import (
            环执行, 客观验证, 状态感知,
            AI调用器接口, 创建环, 创建验证器, 创建状态管理器, 创建AI调用器
        )
        
        # 测试1: 环执行（简化测试）
        try:
            环 = 创建环(最大迭代次数=2)
            状态 = 状态感知.任务状态(迭代次数=0)
            
            调用次数 = [0]
            def 任务(当前状态):
                调用次数[0] += 1
                当前状态.迭代次数 = 调用次数[0]
                return 当前状态
            
            结果 = 环.运行(任务, 状态)
            assert 结果.迭代次数 == 2  # 达到最大迭代次数
            收集器.添加通过("环执行-迭代限制")
        except Exception as e:
            收集器.添加失败("环执行测试", str(e))
        
        # 测试2: 客观验证
        try:
            验证器 = 创建验证器()
            
            # 测试文件存在检查
            结果 = 客观验证.验证文件存在("/tmp")
            assert 结果 == True
            收集器.添加通过("客观验证-文件存在检查")
            
            # 测试目录存在检查
            结果 = 客观验证.验证目录存在("/tmp")
            assert 结果 == True
            收集器.添加通过("客观验证-目录存在检查")
        except Exception as e:
            收集器.添加失败("客观验证测试", str(e))
        
        # 测试3: 状态感知
        try:
            import tempfile
            with tempfile.TemporaryDirectory() as tmpdir:
                状态管理器 = 创建状态管理器(tmpdir)
                
                状态管理器.保存状态({"测试": "数据"})
                收集器.添加通过("状态感知-保存状态")
                
                加载状态 = 状态管理器.加载状态()
                assert 加载状态["测试"] == "数据"
                收集器.添加通过("状态感知-加载状态")
                
                状态管理器.记录日志("测试事件", {"键": "值"})
                收集器.添加通过("状态感知-记录日志")
        except Exception as e:
            收集器.添加失败("状态感知测试", str(e))
        
        # 测试4: AI调用器（模拟）
        try:
            AI调用器 = 创建AI调用器("模拟")
            响应 = AI调用器.调用("你好")
            
            assert 响应["成功"] == True
            assert "模拟AI响应" in 响应["响应"]
            收集器.添加通过("AI调用器-模拟响应")
            
            # 检查调用计数
            assert AI调用器.已调用次数 == 1
            收集器.添加通过("AI调用器-调用计数")
        except Exception as e:
            收集器.添加失败("AI调用器测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("拉尔夫原语模块", f"导入失败: {e}")


def 测试词法分析器模块(收集器: 测试结果收集器):
    """测试词法分析器模块"""
    print("\n" + "=" * 60)
    print("测试 词法分析器模块")
    print("=" * 60)
    
    try:
        from 词法器 import 增强词法分析器, 词法分析
        from 代数数据类型ADT import (
            关键字词法单元, 标识符词法单元, 数字词法单元,
            字符串词法单元, 运算符词法单元, 分隔符词法单元,
            文件结束词法单元
        )
        
        # 测试1: 基本词法分析
        try:
            源代码 = "循环 5 次:"
            分析器 = 增强词法分析器(源代码)
            结果 = 分析器.分析()
            
            assert 结果.不是空()
            词法单元列表 = 结果.获取值()
            assert len(词法单元列表) >= 2
            收集器.添加通过("词法分析-基本分析")
        except Exception as e:
            收集器.添加失败("词法分析-基本测试", str(e))
        
        # 测试2: 关键字识别
        try:
            关键字列表 = ["循环", "验证", "持久化", "调用AI", "如果", "否则", "结束"]
            for 关键字 in 关键字列表:
                分析器 = 增强词法分析器(关键字)
                结果 = 分析器.分析()
                单元列表 = 结果.获取值()
                
                第一个 = 单元列表[0]
                assert isinstance(第一个, 关键字词法单元)
                assert 第一个.值 == 关键字
            收集器.添加通过("词法分析-关键字识别")
        except Exception as e:
            收集器.添加失败("词法分析-关键字测试", str(e))
        
        # 测试3: 数字识别
        try:
            分析器 = 增强词法分析器("123")
            结果 = 分析器.分析()
            单元列表 = 结果.获取值()
            
            数字单元 = 单元列表[0]
            assert isinstance(数字单元, 数字词法单元)
            assert 数字单元.值 == 123
            收集器.添加通过("词法分析-数字识别")
        except Exception as e:
            收集器.添加失败("词法分析-数字测试", str(e))
        
        # 测试4: 字符串识别
        try:
            分析器 = 增强词法分析器('"hello world"')
            结果 = 分析器.分析()
            单元列表 = 结果.获取值()
            
            字符串单元 = 单元列表[0]
            assert isinstance(字符串单元, 字符串词法单元)
            assert 字符串单元.值 == "hello world"
            收集器.添加通过("词法分析-字符串识别")
        except Exception as e:
            收集器.添加失败("词法分析-字符串测试", str(e))
        
        # 测试5: 标识符识别
        try:
            分析器 = 增强词法分析器("变量名")
            结果 = 分析器.分析()
            单元列表 = 结果.获取值()
            
            标识符单元 = 单元列表[0]
            assert isinstance(标识符单元, 标识符词法单元)
            assert 标识符单元.值 == "变量名"
            收集器.添加通过("词法分析-标识符识别")
        except Exception as e:
            收集器.添加失败("词法分析-标识符测试", str(e))
        
        # 测试6: 运算符识别
        try:
            分析器 = 增强词法分析器("==")
            结果 = 分析器.分析()
            单元列表 = 结果.获取值()
            
            运算符单元 = 单元列表[0]
            assert isinstance(运算符单元, 运算符词法单元)
            assert 运算符单元.值 == "=="
            收集器.添加通过("词法分析-运算符识别")
        except Exception as e:
            收集器.添加失败("词法分析-运算符测试", str(e))
        
        # 测试7: 完整程序词法分析
        try:
            完整程序 = """
循环 5:
    验证 "test"
    如果 验证通过:
        持久化
    结束
结束
"""
            分析器 = 增强词法分析器(完整程序)
            结果 = 分析器.分析()
            
            assert 结果.不是空()
            词法单元列表 = 结果.获取值()
            
            # 检查文件结束单元
            最后一个 = 词法单元列表[-1]
            assert isinstance(最后一个, 文件结束词法单元)
            收集器.添加通过("词法分析-完整程序")
        except Exception as e:
            收集器.添加失败("词法分析-完整程序测试", str(e))
        
        # 测试8: 错误处理
        try:
            分析器 = 增强词法分析器("@#@#")
            结果 = 分析器.分析()
            # 应该记录错误
            assert 分析器.有错误() or 结果.是空()
            收集器.添加通过("词法分析-错误处理")
        except Exception as e:
            收集器.添加失败("词法分析-错误测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("词法分析器模块", f"导入失败: {e}")


def 测试栈机核心模块(收集器: 测试结果收集器):
    """测试栈机核心模块"""
    print("\n" + "=" * 60)
    print("测试 栈机核心模块")
    print("=" * 60)
    
    try:
        from 栈机核心 import 纯栈机虚拟机, 创建栈机, 栈机状态
        from 代数数据类型ADT import 指令
        
        # 测试1: 虚拟机创建
        try:
            栈机 = 创建栈机()
            assert 栈机.程序计数器 == 0
            assert 栈机.运行标志 == True
            收集器.添加通过("栈机创建")
        except Exception as e:
            收集器.添加失败("栈机创建测试", str(e))
        
        # 测试2: 加载和执行简单程序
        try:
            栈机 = 创建栈机()
            
            指令序列 = [
                指令("推入", 10),
                指令("推入", 20),
                指令("加法"),
                指令("打印")
            ]
            
            栈机.加载程序(指令序列)
            收集器.添加通过("加载程序")
            
            # 手动执行
            while 栈机.运行标志 and 栈机.程序计数器 < len(指令序列):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            assert 栈机.指令计数 == 4
            assert 栈机.操作数栈[-1] == 30  # 10 + 20 = 30
            收集器.添加通过("算术运算执行")
        except Exception as e:
            收集器.添加失败("算术运算测试", str(e))
        
        # 测试3: 减法
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("推入", 100),
                指令("推入", 30),
                指令("减法")
            ]
            
            栈机.加载程序(指令序列)
            for _ in range(3):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            assert 栈机.操作数栈[-1] == 70  # 100 - 30 = 70
            收集器.添加通过("减法运算")
        except Exception as e:
            收集器.添加失败("减法测试", str(e))
        
        # 测试4: 乘法
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("推入", 5),
                指令("推入", 6),
                指令("乘法")
            ]
            
            栈机.加载程序(指令序列)
            for _ in range(3):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            assert 栈机.操作数栈[-1] == 30  # 5 * 6 = 30
            收集器.添加通过("乘法运算")
        except Exception as e:
            收集器.添加失败("乘法测试", str(e))
        
        # 测试5: 除法
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("推入", 100),
                指令("推入", 4),
                指令("除法")
            ]
            
            栈机.加载程序(指令序列)
            for _ in range(3):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            assert 栈机.操作数栈[-1] == 25.0  # 100 / 4 = 25
            收集器.添加通过("除法运算")
        except Exception as e:
            收集器.添加失败("除法测试", str(e))
        
        # 测试6: 比较运算
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("推入", 10),
                指令("推入", 20),
                指令("大于")
            ]
            
            栈机.加载程序(指令序列)
            for _ in range(3):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            assert 栈机.操作数栈[-1] == 0  # 10 > 20 = False
            收集器.添加通过("比较运算")
        except Exception as e:
            收集器.添加失败("比较测试", str(e))
        
        # 测试7: 栈操作
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("推入", 1),
                指令("推入", 2),
                指令("复制栈顶"),
                指令("推入", 3)
            ]
            
            栈机.加载程序(指令序列)
            for i in range(4):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            # 栈应该包含: [1, 2, 2, 3]
            assert len(栈机.操作数栈) == 4
            assert 栈机.操作数栈[-1] == 3
            收集器.添加通过("栈操作")
        except Exception as e:
            收集器.添加失败("栈操作测试", str(e))
        
        # 测试8: 标签和跳转
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("标签", "开始"),
                指令("推入", 1),
                指令("推入", 0),
                指令("条件跳转", "结束"),
                指令("停机"),
                指令("标签", "结束")
            ]
            
            栈机.加载程序(指令序列)
            
            # 条件跳转：0为假，不跳转
            栈机.执行单条指令()  # 标签
            栈机.执行单条指令()  # 推入 1
            栈机.执行单条指令()  # 推入 0
            栈机.执行单条指令()  # 条件跳转，0为假，不跳转
            栈机.程序计数器 += 1
            
            assert 栈机.程序计数器 == 5  # 跳过了停机指令
            收集器.添加通过("条件跳转")
        except Exception as e:
            收集器.添加失败("条件跳转测试", str(e))
        
        # 测试9: 内存操作
        try:
            栈机 = 创建栈机()
            指令序列 = [
                指令("推入", 42),
                指令("存储", 0),  # 存储到地址0
                指令("推入", 0),  # 加载地址0
                指令("加载", 0)
            ]
            
            栈机.加载程序(指令序列)
            for i in range(4):
                栈机.执行单条指令()
                栈机.程序计数器 += 1
            
            assert 栈机.操作数栈[-1] == 42
            收集器.添加通过("内存操作")
        except Exception as e:
            收集器.添加失败("内存操作测试", str(e))
        
        # 测试10: 状态获取
        try:
            栈机 = 创建栈机()
            状态 = 栈机.获取状态()
            assert isinstance(状态, 栈机状态)
            assert 状态.程序计数器 == 0
            assert 状态.运行标志 == True
            收集器.添加通过("状态获取")
        except Exception as e:
            收集器.添加失败("状态获取测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("栈机核心模块", f"导入失败: {e}")


def 测试解析器模块(收集器: 测试结果收集器):
    """测试解析器模块"""
    print("\n" + "=" * 60)
    print("测试 解析器模块")
    print("=" * 60)
    
    try:
        from 解析器 import 增强递归下降解析器, 解析
        from 词法器 import 增强词法分析器
        from 代数数据类型ADT import 程序节点, 循环节点, 验证节点
        
        # 测试1: 解析简单程序
        try:
            源代码 = "循环 5: 结束"
            
            # 先词法分析
            词法分析器 = 增强词法分析器(源代码)
            词法结果 = 词法分析器.分析()
            
            assert 词法结果.不是空()
            词法单元列表 = 词法结果.获取值()
            
            # 再语法分析
            解析器 = 增强递归下降解析器(词法单元列表)
            解析结果 = 解析器.解析()
            
            assert 解析结果.不是空()
            AST = 解析结果.获取值()
            assert isinstance(AST, 程序节点)
            收集器.添加通过("解析简单程序")
        except Exception as e:
            收集器.添加失败("解析简单程序测试", str(e))
        
        # 测试2: 解析循环语句
        try:
            源代码 = """
循环 3:
    验证 "test"
结束
"""
            词法分析器 = 增强词法分析器(源代码)
            词法结果 = 词法分析器.分析()
            
            解析器 = 增强递归下降解析器(词法结果.获取值())
            解析结果 = 解析器.解析()
            
            assert 解析结果.不是空()
            AST = 解析结果.获取值()
            assert len(AST.语句列表) == 1
            assert isinstance(AST.语句列表[0], 循环节点)
            收集器.添加通过("解析循环语句")
        except Exception as e:
            收集器.添加失败("解析循环语句测试", str(e))
        
        # 测试3: 解析表达式
        try:
            源代码 = "1 + 2 * 3"
            
            词法分析器 = 增强词法分析器(源代码)
            词法结果 = 词法分析器.分析()
            
            解析器 = 增强递归下降解析器(词法结果.获取值())
            解析结果 = 解析器.解析()
            
            assert 解析结果.不是空()
            AST = 解析结果.获取值()
            assert len(AST.语句列表) == 1
            收集器.添加通过("解析表达式")
        except Exception as e:
            收集器.添加失败("解析表达式测试", str(e))
        
        # 测试4: 解析条件语句
        try:
            源代码 = """
如果 验证通过:
    持久化
否则:
    调用AI "失败"
结束
"""
            词法分析器 = 增强词法分析器(源代码)
            词法结果 = 词法分析器.分析()
            
            解析器 = 增强递归下降解析器(词法结果.获取值())
            解析结果 = 解析器.解析()
            
            assert 解析结果.不是空()
            AST = 解析结果.获取值()
            收集器.添加通过("解析条件语句")
        except Exception as e:
            收集器.添加失败("解析条件语句测试", str(e))
        
        # 测试5: 错误恢复
        try:
            源代码 = "无效代码 @#$"
            
            词法分析器 = 增强词法分析器(源代码)
            词法结果 = 词法分析器.分析()
            
            # 应该记录错误
            assert 词法分析器.有错误() or 词法结果.是空()
            收集器.添加通过("解析错误处理")
        except Exception as e:
            收集器.添加失败("解析错误测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("解析器模块", f"导入失败: {e}")


def 测试代码生成器模块(收集器: 测试结果收集器):
    """测试代码生成器模块"""
    print("\n" + "=" * 60)
    print("测试 代码生成器模块")
    print("=" * 60)
    
    try:
        from 代码生成器 import 增强代码生成器, 生成代码
        from 代数数据类型ADT import (
            程序节点, 循环节点, 块节点, 验证节点,
            字面量节点, 标识符节点
        )
        
        # 测试1: 生成简单程序代码
        try:
            程序 = 程序节点(语句列表=[
                字面量节点(值=10, 类型="整数"),
                字面量节点(值=20, 类型="整数"),
            ])
            
            生成器 = 增强代码生成器()
            指令序列 = 生成器.生成代码(程序)
            
            assert len(指令序列) >= 2
            收集器.添加通过("生成简单程序代码")
        except Exception as e:
            收集器.添加失败("生成简单程序代码测试", str(e))
        
        # 测试2: 生成循环代码
        try:
            程序 = 程序节点(语句列表=[
                循环节点(
                    循环次数=字面量节点(值=3, 类型="整数"),
                    循环体=块节点(语句列表=[
                        字面量节点(值=1, 类型="整数")
                    ])
                )
            ])
            
            生成器 = 增强代码生成器()
            指令序列 = 生成器.生成代码(程序)
            
            # 应该生成标签、跳转等指令
            标签列表 = [ins for ins in 指令序列 if ins.操作码 == "标签"]
            跳转列表 = [ins for ins in 指令序列 if ins.操作码 == "跳转"]
            
            assert len(标签列表) >= 2  # 循环开始和结束
            assert len(跳转列表) >= 1  # 循环跳转
            收集器.添加通过("生成循环代码")
        except Exception as e:
            收集器.添加失败("生成循环代码测试", str(e))
        
        # 测试3: 符号表
        try:
            生成器 = 增强代码生成器()
            符号表 = 生成器.获取符号表()
            assert isinstance(符号表, dict)
            收集器.添加通过("符号表操作")
        except Exception as e:
            收集器.添加失败("符号表测试", str(e))
        
        # 测试4: 指令序列输出
        try:
            程序 = 程序节点(语句列表=[
                字面量节点(值=42, 类型="整数")
            ])
            
            生成器 = 增强代码生成器()
            指令序列 = 生成器.生成代码(程序)
            
            # 测试输出（不应该报错）
            生成器.输出代码()
            收集器.添加通过("指令序列输出")
        except Exception as e:
            收集器.添加失败("指令输出测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("代码生成器模块", f"导入失败: {e}")


def 测试编译管道模块(收集器: 测试结果收集器):
    """测试编译管道模块"""
    print("\n" + "=" * 60)
    print("测试 编译管道模块")
    print("=" * 60)
    
    try:
        from 编译管道 import 拉尔夫编译管道, 编译管道配置, 编译
        
        # 测试1: 基本编译
        try:
            源代码 = """
循环 2:
    验证 "test"
结束
"""
            管道 = 拉尔夫编译管道()
            结果 = 管道.编译(源代码)
            
            assert 结果.不是空()
            指令序列 = 结果.获取值()
            assert len(指令序列) > 0
            收集器.添加通过("基本编译")
        except Exception as e:
            收集器.添加失败("基本编译测试", str(e))
        
        # 测试2: 复杂程序编译
        try:
            源代码 = """
循环 3:
    验证 "python test.py"
    
    如果 验证通过:
        持久化 "./结果.json"
    否则:
        调用AI "测试失败"
    结束
结束
"""
            管道 = 拉尔夫编译管道()
            结果 = 管道.编译(源代码)
            
            assert 结果.不是空()
            指令序列 = 结果.获取值()
            assert len(指令序列) > 10  # 应该生成多条指令
            收集器.添加通过("复杂程序编译")
        except Exception as e:
            收集器.添加失败("复杂程序编译测试", str(e))
        
        # 测试3: 编译报告
        try:
            源代码 = "循环 1: 结束"
            
            管道 = 拉尔夫编译管道()
            结果 = 管道.编译(源代码)
            
            报告 = 管道.生成编译报告()
            assert "编译状态" in 报告
            assert "词法单元数量" in 报告
            assert "错误列表" in 报告
            收集器.添加通过("编译报告生成")
        except Exception as e:
            收集器.添加失败("编译报告测试", str(e))
        
        # 测试4: 便捷编译函数
        try:
            源代码 = "循环 1: 结束"
            
            结果 = 编译(源代码)
            assert 结果.不是空()
            收集器.添加通过("便捷编译函数")
        except Exception as e:
            收集器.添加失败("便捷编译函数测试", str(e))
        
        # 测试5: 错误处理
        try:
            源代码 = "无效语法 @#$"
            
            管道 = 拉尔夫编译管道()
            结果 = 管道.编译(源代码)
            
            # 应该失败
            assert 结果.是空() or 管道.有错误()
            收集器.添加通过("编译错误处理")
        except Exception as e:
            收集器.添加失败("编译错误测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("编译管道模块", f"导入失败: {e}")


def 测试集成工作流(收集器: 测试结果收集器):
    """测试完整集成工作流"""
    print("\n" + "=" * 60)
    print("测试 完整工作流")
    print("=" * 60)
    
    try:
        from 完整工作流 import 完整工作流, 拉尔夫韦根系统
        
        # 测试1: 简单工作流
        try:
            源代码 = "循环 1: 结束"
            
            工作流 = 完整工作流()
            编译成功 = 工作流.编译程序(源代码)
            
            assert 编译成功
            收集器.添加通过("工作流编译")
        except Exception as e:
            收集器.添加失败("工作流编译测试", str(e))
        
        # 测试2: 完整编译执行
        try:
            源代码 = """
循环 2:
    验证 "echo test"
结束
"""
            工作流 = 完整工作流(配置={
                "优化级别": 1,
                "调试模式": False,
                "内存大小": 65536
            })
            
            # 编译
            编译成功 = 工作流.编译程序(源代码)
            assert 编译成功
            
            # 执行
            执行结果 = 工作流.执行程序(调试模式=False)
            
            assert "执行指令数" in 执行结果
            assert 执行结果["执行指令数"] > 0
            收集器.添加通过("完整工作流执行")
        except Exception as e:
            收集器.添加失败("完整工作流测试", str(e))
        
        # 测试3: 执行报告
        try:
            源代码 = "循环 1: 结束"
            
            工作流 = 完整工作流()
            工作流.编译程序(源代码)
            工作流.执行程序(调试模式=False)
            
            报告 = 工作流.生成执行报告()
            assert "程序信息" in 报告
            assert "执行结果" in 报告
            收集器.添加通过("执行报告生成")
        except Exception as e:
            收集器.添加失败("执行报告测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("完整工作流", f"导入失败: {e}")


def 测试调试器模块(收集器: 测试结果收集器):
    """测试调试器模块"""
    print("\n" + "=" * 60)
    print("测试 调试器模块")
    print("=" * 60)
    
    try:
        from 集成调试器 import 拉尔夫集成调试器, 创建调试器, 断点
        from 栈机核心 import 创建栈机
        from 代数数据类型ADT import 指令
        
        # 测试1: 调试器创建
        try:
            虚拟机 = 创建栈机()
            调试器 = 创建调试器(虚拟机)
            assert 调试器 is not None
            收集器.添加通过("调试器创建")
        except Exception as e:
            收集器.添加失败("调试器创建测试", str(e))
        
        # 测试2: 断点设置
        try:
            调试器 = 创建调试器()
            结果 = 调试器.设置断点(10, "条件: x > 5")
            assert 结果 == True
            
            # 检查断点是否设置
            assert 10 in 调试器.断点字典
            断点 = 调试器.断点字典[10]
            assert 断点.条件 == "条件: x > 5"
            收集器.添加通过("断点设置")
        except Exception as e:
            收集器.添加失败("断点设置测试", str(e))
        
        # 测试3: 断点删除
        try:
            调试器 = 创建调试器()
            调试器.设置断点(5)
            结果 = 调试器.删除断点(5)
            assert 结果 == True
            assert 5 not in 调试器.断点字典
            收集器.添加通过("断点删除")
        except Exception as e:
            收集器.添加失败("断点删除测试", str(e))
        
        # 测试4: 监视表达式
        try:
            调试器 = 创建调试器()
            调试器.添加监视表达式("栈深度")
            调试器.添加监视表达式("程序计数器")
            
            assert len(调试器.监视表达式列表) == 2
            收集器.添加通过("监视表达式")
        except Exception as e:
            收集器.添加失败("监视表达式测试", str(e))
        
        # 测试5: 调试报告
        try:
            虚拟机 = 创建栈机()
            虚拟机.加载程序([指令("推入", 1)])
            
            调试器 = 创建调试器(虚拟机)
            报告 = 调试器.生成调试报告()
            
            assert "程序计数器" in 报告
            assert "操作数栈深度" in 报告
            收集器.添加通过("调试报告生成")
        except Exception as e:
            收集器.添加失败("调试报告测试", str(e))
        
        # 测试6: 表达式求值
        try:
            虚拟机 = 创建栈机()
            虚拟机.加载程序([
                指令("推入", 10),
                指令("推入", 20)
            ])
            
            调试器 = 创建调试器(虚拟机)
            
            # 执行指令使栈有数据
            for i in range(2):
                虚拟机.执行单条指令()
            
            上下文 = 调试器._创建调试上下文()
            assert 上下文["栈深度"] == 2
            收集器.添加通过("表达式求值上下文")
        except Exception as e:
            收集器.添加失败("表达式求值测试", str(e))
    
    except ImportError as e:
        收集器.添加跳过("调试器模块", f"导入失败: {e}")


def 运行所有测试():
    """运行所有测试"""
    print("=" * 60)
    print("拉尔夫编译器完整测试套件")
    print("=" * 60)
    
    收集器 = 测试结果收集器()
    
    # 按依赖顺序运行测试
    测试异常处理模块(收集器)
    测试代数数据类型模块(收集器)
    测试拉尔夫原语模块(收集器)
    测试词法分析器模块(收集器)
    测试栈机核心模块(收集器)
    测试解析器模块(收集器)
    测试代码生成器模块(收集器)
    测试编译管道模块(收集器)
    测试调试器模块(收集器)
    测试集成工作流(收集器)
    
    # 输出最终报告
    成功 = 收集器.输出报告()
    
    return 成功


if __name__ == "__main__":
    成功 = 运行所有测试()
    sys.exit(0 if 成功 else 1)
